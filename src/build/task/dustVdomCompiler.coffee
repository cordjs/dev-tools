fs     = require 'fs'
_      = require 'underscore'

Future = require '../../utils/Future'

dustVdom = require './dust-vdom'


# counter that helps generate block functions names
blockFnNameCounter = 0


exports.compile = (src, indent = 1) ->
  Future.call(fs.readFile, src, 'utf8').then (dustString) ->
    ast = dustVdom.parse(dustString)
    if ast.length > 1
      console.warn "Only single root node is allowed for the widget! Using only first of #{ast.length}! [#{src}]"
      ast = [ast[0]]
    blockFnNameCounter = 0
    astToHyperscript(ast, indent)


astToHyperscript = (ast, indent = 0) ->
  ###
  Recursively converts AST subtree to the hyperscript code fragment
  @param {Array.<Object>} ast - list of entries generated by pegjs parser
  @param {number=} indent - integer indentation level (to generate properly formatted code)
  @return {Object} structure with three fields:
                   * usedContext {Array.<string>} - list of vars used in this section of ast and need to be passed down
                   * blockFns {Array.<string>} - list of compiled block functions that need to be included as a private
                                                 functions to the script
                   * hyperscript {string} - JS-code, hyperscript section of the given AST including children sections,
                                            refers to the functions declared in blockFns
  ###
  indentPrefix = (new Array(indent * 2 + 1)).join(' ')
  prevIndentPrefix = if indent > 0 then (new Array((indent - 1) * 2 + 1)).join(' ') else ''
  childIndent = if ast.length > 1 then "\n#{indentPrefix}" else ''
  resultInfo =
    usedContext: []
    blockFns: []
  chunks =
    for node in ast
      switch node.type
        when 'html_tag'
          if node.name == 'widget'
            compileWidget(node, indent)
          else
            contentsStr = ''
            if node.contents
              contentsInfo = astToHyperscript(node.contents, indent + 1)
              contentsStr = ', ' + contentsInfo.hyperscript  if contentsInfo.hyperscript
              resultInfo.usedContext = _.union(resultInfo.usedContext, contentsInfo.usedContext)
              resultInfo.blockFns = contentsInfo.blockFns.concat(resultInfo.blockFns)

            propsInfo = propsToHyperscript(node.props, indent)

            "h('#{node.name}#{propsInfo.idStr}'#{propsInfo.propsStr}#{contentsStr})"

        when 'section'
          # {?someVar}contents{/someVar} - if-block
          if node.modifier == '?'
            if node.contents
              contentsInfo = astToHyperscript(node.contents, indent + 1)
              resultInfo.blockFns = contentsInfo.blockFns.concat(resultInfo.blockFns)
              localUsedContext = _.union(contentsInfo.usedContext, detectUsedContext(node.name))
              resultInfo.usedContext = _.union(resultInfo.usedContext, localUsedContext)
              fnName = createBlockFn(
                resultInfo.blockFns, localUsedContext, "if (#{node.name}) { return #{contentsInfo.hyperscript}; }"
              )
              formatBlockFnCall(fnName, localUsedContext)
            else
              # if contents is empty then condition doesn't matter
              undefined
          else
            throw new Error("Modifier '#{node.modifier}' for section #{node.name} is not supported yet!")

        when 'text'
          "'#{node.text}'"

        when 'expr'
          resultInfo.usedContext = _.union(resultInfo.usedContext, detectUsedContext(node.code))
          node.code

  chunks = mergeTextChunks(chunks, ast)

  resultInfo.hyperscript =
    if chunks.length > 1
      "[#{childIndent}#{chunks.join(',' + childIndent)}\n#{prevIndentPrefix}]"
    else if chunks.length == 1
      chunks[0]
    else
      ''

  resultInfo


compileWidget = (node, indent = 0) ->
  contentsStr = ''
  contentsStr = astToHyperscript(node.contents, indent + 1) if node.contents
  contentsStr = ', ' + contentsStr if contentsStr

  for prop, i in node.props
    if prop.name == 'type'
      type = compilePropValue(prop.value)
      node.props.splice(i, 1)
      break

  propsInfo = propsToHyperscript(node.props, indent)

  "w(#{type}#{propsInfo.propsStr}#{contentsStr})"


compilePropValue = (propValue) ->
  if _.isString(propValue)
    "'#{propValue}'"
  else if _.isObject(propValue)
    switch propValue.type
      when 'expr' then propValue.code
      else
        throw new Error("Invalid prop value type '#{propValue.type}'!")
  else
    throw new Error("Invalid prop value type parsed: #{propValue}!")


mergeTextChunks = (chunks, ast) ->
  ###
  Minimizes number of text nodes in the resulting vtree by merging neighbour text chunks and expressions
   into one call of v() function that handles async values of expressions.
  Single text chunks and expressions doesn't need to be wrapped into v()
  @param {Array.<string>} chunks
  @param {Array.<Object>} ast
  @return {Array.<string>} shortened list of chunks
  ###
  result = []
  prevVtext = false
  chainStarted = false
  for node, i in ast
    if chunks[i]?  # undefined and null is just ignored
      curVtext = node.type in ['text', 'expr']
      if curVtext and prevVtext
        if chainStarted
          result[result.length - 1].push(chunks[i])
        else
          result[result.length - 1] = [result[result.length - 1], chunks[i]]
          chainStarted = true
      else
        if chainStarted
          result[result.length - 1] = 'v(' + result[result.length - 1].join(', ') + ')'
          chainStarted = false
        result.push(chunks[i])
      prevVtext = curVtext
  if chainStarted
    result[result.length - 1] = 'v(' + result[result.length - 1].join(', ') + ')'
  result


propsToHyperscript = (props, indent = 0) ->
  ###
  Converts props came from AST to the JSON to be added to the hyperscript code
  `id` property is treated separately
  @param {Array.<Object>} props
  @param {number} indent
  @return {Object} structure with two fields:
                   * idStr {string} - hyperscript shortcut for id property if applicable (like a#my-id)
                   * propsStr {string} - formatted props JSON object to be added to hyperscript
  ###
  result =
    idStr: ''
    propsStr: ''
  return result  if not props

  chunks = []
  for propInfo in props
    if propInfo.name != 'id' or not _.isString(propInfo.value) # only hard-coded ids are represented in shortcut format
      value = compilePropValue(propInfo.value)
      chunks.push("#{propInfo.name}: #{value}")
    else
      result.idStr = '#' + propInfo.value

  return result  if chunks.length == 0

  pairs =
    if chunks.length > 1
      indentStr = "\n" + (new Array((indent + 1) * 2 + 1)).join(' ')
      prevIndentPrefix = (new Array(indent * 2 + 1)).join(' ')
      "#{indentStr}#{chunks.join(',' + indentStr)}\n#{prevIndentPrefix}"
    else
      " #{chunks[0]} "
  result.propsStr = ", {#{pairs}}"
  result


createBlockFn = (fns, argNames, body) ->
  ###
  Generates a new block function and adds it to the given block functions container
  @param {Array.<string>} fns - container of the block function to which the generated function is added
  @param {Array.<string>} argNames - list of argument names of the declared function
  @param {string} body - JS-code of the given function (without braces)
  @return {string} name of the created function
  ###
  fnName = 'b' + (blockFnNameCounter++)
  fns.push("function #{fnName}(#{argNames.join(', ')}) { #{body} }")
  fnName


formatBlockFnCall = (fnName, argNames) ->
  ###
  Returns JS function-call code by the function name and list of arguments
  @param {string} fnName
  @param {Array.<string>} argNames
  @return {string}
  ###
  "#{fnName}(#{argNames.join(', ')})"


possibleContextNames = ['props', 'state', 'calc']

detectUsedContext = (code) ->
  ###
  Finds used context roots in the given JS-code using dumb substring matching
  @param {string} code
  @return {Array.<string>}
  ###
  possibleContextNames.filter (x) -> code.indexOf(x) > -1
