// Generated by CoffeeScript 1.9.1
var defineFuture,
  slice = [].slice;

defineFuture = function(_) {
  var Future;
  return Future = (function() {

    /*
    Simple aggregative future/promise class.
    
    Two scenarios are supported:
    1. Do something when all async actions in loop are complete.
    2. Aggregate several typical async-callback functions result into one callback call.
    
    Example of 1:
      promise = new Future
      result = []
      for i in [1..10]
        do (i) =>
          promise.fork()
          setTimeout ->
            result.push(i)
            promise.resolve()
          , 1000
      promise.done ->
        _console.log result.join(', ')
    
    Example of 2:
      asyncGetter = (key, callback) ->
        obj =
          test: [1, 2, 3, 4, 5]
        setTimeout ->
          callback(obj[key])
        , 500
    
      promise = new Future
      require ['jquery', 'underscore'], promise.callback()
      asyncGetter 'test', promise.callback()
      promise.done ($, _, testVal) ->
        $('body').html("Even vals of 'test' = #{ _.filter(testVal, (num) -> num % 2 == 0) }")
     */
    Future.prototype._counter = 0;

    Future.prototype._doneCallbacks = null;

    Future.prototype._failCallbacks = null;

    Future.prototype._alwaysCallbacks = null;

    Future.prototype._order = 0;

    Future.prototype._callbackArgs = null;

    Future.prototype._locked = false;

    Future.prototype._completed = false;

    Future.prototype._state = 'pending';

    Future.prototype._name = '';

    Future.prototype._incompleteTimeout = null;

    function Future(initialCounter, name) {
      if (initialCounter == null) {
        initialCounter = 0;
      }
      if (name == null) {
        name = ':noname:';
      }

      /*
      @param (optional)Int initialCounter initial state of counter, syntax sugar to avoid (new Future).fork().fork()
      @param (optional)String name individual name of the future to separate it from others during debugging
       */
      if ((initialCounter != null) && _.isString(initialCounter)) {
        name = initialCounter;
        initialCounter = 0;
      }
      this._counter = initialCounter;
      this._doneCallbacks = [];
      this._failCallbacks = [];
      this._alwaysCallbacks = [];
      this._name = name;
      if (this._counter > 0) {
        this._initDebugTimeout();
      }
    }

    Future.prototype.fork = function() {

      /*
      Adds one more value to wait.
      Should be paired with following resolve() call.
      @return Future(self)
       */
      if (this._completed && !(this._state === 'rejected' && this._counter > 0)) {
        throw new Error("Trying to use the completed future [" + this._name + "]!");
      }
      if (this._locked) {
        throw new Error("Trying to fork locked future [" + this._name + "]!");
      }
      this._counter++;
      if (this._counter === 1) {
        this._initDebugTimeout();
      }
      return this;
    };

    Future.prototype.resolve = function() {
      var args, nameStr;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /*
      Indicates that one of the waiting values is ready.
      If there are some arguments passed then they are passed unchanged to the done-callbacks.
      If there is no value remaining in the aggregate and done method is already called
       than callback is fired immediately.
      Should have according fork() call before.
       */
      if (this._counter > 0) {
        this._counter--;
        if (this._state !== 'rejected') {
          if (args.length > 0) {
            this._callbackArgs = [args];
          }
          if (this._counter === 0) {
            if (this._locked) {
              this._state = 'resolved';
            }
            if (this._doneCallbacks.length > 0) {
              this._runDoneCallbacks();
            }
            if (this._alwaysCallbacks.length > 0) {
              this._runAlwaysCallbacks();
            }
            if (this._state === 'resolved') {
              this._clearFailCallbacks();
            }
            this._clearDebugTimeout();
          }
        }
      } else {
        nameStr = this._name ? " (name = " + this._name + ")" : '';
        throw new Error("Future::resolve() is called more times than Future::fork!" + nameStr);
      }
      return this;
    };

    Future.prototype.reject = function(err) {

      /*
      Indicates that the promise is rejected (failed) and fail-callbacks should be called.
      If there are some arguments passed then they are passed unchanged to the fail-callbacks.
      If fail-method is already called than callbacks are fired immediately, otherwise they'll be fired
       when fail-method is called.
      Only first call of this method is important. Any subsequent calls does nothing but decrementing the counter.
       */
      if (this._counter > 0) {
        this._counter--;
        if (this._state !== 'rejected') {
          this._state = 'rejected';
          this._callbackArgs = [err != null ? err : new Error("Future[" + this._name + "] rejected without error message!")];
          if (this._failCallbacks.length > 0) {
            this._runFailCallbacks();
          }
          if (this._alwaysCallbacks.length > 0) {
            this._runAlwaysCallbacks();
          }
          this._clearDoneCallbacks();
          this._clearDebugTimeout();
        }
      } else {
        throw new Error("Future::reject is called more times than Future::fork! [" + this._name + "]");
      }
      return this;
    };

    Future.prototype.complete = function() {
      var args, err;
      err = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];

      /*
      Completes this promise either with successful of failure result depending on the arguments.
      If first argument is not null than the promise is completed with reject using first argument as an error.
      Otherwise remaining arguments are used for promise.resolve() call.
      This method is useful to work with lots of APIs using such semantics of the callback agruments.
       */
      if (err != null) {
        return this.reject(err);
      } else {
        return this.resolve.apply(this, args);
      }
    };

    Future.prototype.when = function() {
      var args, j, len1, promise;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /*
      Adds another future(promise)(s) as a condition of completion of this future
      Can be called multiple times.
      @param (variable)Future args another future which'll be waited
      @return Future self
       */
      for (j = 0, len1 = args.length; j < len1; j++) {
        promise = args[j];
        if (!this._locked) {
          this.fork();
        }
        promise.done((function(_this) {
          return function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.resolve.apply(_this, args);
          };
        })(this)).fail((function(_this) {
          return function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.reject.apply(_this, args);
          };
        })(this));
      }
      return this;
    };

    Future.prototype.link = function(anotherPromise) {

      /*
      Inversion of `when` method. Tells that the given future will complete when this future will complete.
      Just syntax sugar to convert anotherFuture.when(future) to future.link(anotherFuture).
      In some cases using link instead of when leads to more elegant code.
      @param Future anotherFuture
      @return Future self
       */
      anotherPromise.when(this);
      return this;
    };

    Future.prototype.done = function(callback) {

      /*
      Defines callback function to be called when future is resolved.
      If all waiting values are already resolved then callback is fired immedialtely.
      If done method is called several times than all passed functions will be called.
       */
      if (this._state !== 'rejected') {
        this._doneCallbacks.push(callback);
        if (this._counter === 0) {
          this._clearDebugTimeout();
          process.nextTick((function(_this) {
            return function() {
              _this._runDoneCallbacks();
              return _this._clearFailCallbacks();
            };
          })(this));
        }
      }
      return this;
    };

    Future.prototype.fail = function(callback) {

      /*
      Defines callback function to be called when future is rejected.
      If all waiting values are already resolved then callback is fired immedialtely.
      If fail method is called several times than all passed functions will be called.
       */
      if (!_.isFunction(callback)) {
        throw new Error("Invalid argument for Future.fail(): " + callback + ". [" + this._name + "]");
      }
      if (this._state !== 'resolved') {
        this._failCallbacks.push(callback);
        if (this._state === 'rejected') {
          this._clearDebugTimeout();
          process.nextTick((function(_this) {
            return function() {
              return _this._runFailCallbacks();
            };
          })(this));
        }
      }
      return this;
    };

    Future.prototype["finally"] = function(callback) {

      /*
      Defines callback function to be called when future is completed by any mean.
      Callback arguments are using popular semantics with first-argument-as-an-error (Left) and other arguments
       are successful results of the future.
       */
      this._alwaysCallbacks.push(callback);
      if (this._counter === 0 || this._state === 'rejected') {
        this._clearDebugTimeout();
        process.nextTick((function(_this) {
          return function() {
            _this._runAlwaysCallbacks();
            if (_this._state === 'resolved') {
              return _this._clearFailCallbacks();
            }
          };
        })(this));
      }
      return this;
    };

    Future.prototype.failAloud = function(message) {

      /*
      Adds often-used scenario of fail that just throws exception with the error
       */
      var name;
      name = this._name;
      return this.fail(function(err) {
        if (typeof _console !== 'undefined') {
          _console.error("Future(" + name + ")::failAloud" + (message ? " with message: " + message : ''), err);
        } else {
          console.error("Future(" + name + ")::failAloud" + (message ? " with message: " + message : ''), err);
        }
        throw err;
      });
    };

    Future.prototype.callback = function() {
      var neededArgs, order;
      neededArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /*
      Generates callback proxy function to be used in return-in-async-callback functions
       which allows to avoid callback-indentation hell by merging callback callback calls
       of several such functions into one callback which is called when all async functions
       are complete.
      
      All arguments of aggregated callbacks are passed to 'done'-defined callback in order of calling
       'callback' method.
      
      @see example 2 in class documentation block
       */
      this.fork();
      order = this._order++;
      if (this._callbackArgs == null) {
        this._callbackArgs = {};
      }
      return (function(_this) {
        return function() {
          var args, i, j, len1, result;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if (_this._state !== 'rejected') {
            if (neededArgs.length) {
              result = [];
              for (j = 0, len1 = neededArgs.length; j < len1; j++) {
                i = neededArgs[j];
                result.push(args[i]);
              }
            } else {
              result = args;
            }
            _this._callbackArgs[order] = result;
          }
          return _this.resolve();
        };
      })(this);
    };

    Future.prototype.completed = function() {

      /*
      Indicates that callbacks() are already called at least once and fork() cannot be called anymore
      @return Boolean
       */
      if (!this._completed && this._counter === 0) {
        this._completed = true;
      }
      return this._completed;
    };

    Future.prototype.state = function() {

      /*
      Returns state of the promise - 'pending', 'resolved' or 'rejected'
      @return String
       */
      return this._state;
    };

    Future.prototype.lock = function() {
      this._locked = true;
      return this;
    };

    Future.prototype.then = function(onResolved, onRejected) {

      /*
      Implements 'then'-samantics to be compatible with standard JS Promise.
      Both arguments are optional but at least on of them must be defined!
      @param (optional)Function onResolved callback to be evaluated in case of successful resolving of the promise
                                           This is the same as using of combination of map() or flatMap()
                                           (depending of the callback's returned type).
                                           If the Future returned then it's result is proxied to the then-result Future.
                                           Returned Array is spread into same number of callback arguments.
                                           If exception is thrown then it's wrapped into rejected Future and returned.
                                           Any other return value is just returned wrappend into resulting Future.
      @param (optional)Function onRejected callback to be evaluated in case of the promise rejection
                                           This is the same as using recover() method.
                                           Return value behaviour is the same as for `onResolved` callback
      @return Future[A]
       */
      var result;
      if ((onResolved == null) && (onRejected == null)) {
        throw new Error("No callback given for Future.then (name = " + this._name + ")!");
      }
      result = Future.single(this._name + " -> then");
      if (onResolved != null) {
        this.done(function() {
          var args, err, res;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          try {
            res = onResolved.apply(null, args);
            if ((res instanceof Future) || (res && _.isFunction(res.then))) {
              return result.when(res);
            } else if (_.isArray(res)) {
              return result.resolve.apply(result, res);
            } else {
              return result.resolve(res);
            }
          } catch (_error) {
            err = _error;
            if (result.completed()) {
              throw err;
            } else {
              return result.reject(err);
            }
          }
        });
      } else {
        this.done(function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return result.resolve.apply(result, args);
        });
      }
      if (onRejected != null) {
        this.fail(function(err) {
          var err1, res;
          try {
            res = onRejected.call(null, err);
            if ((res instanceof Future) || (res && _.isFunction(res.then))) {
              return result.when(res);
            } else if (_.isArray(res)) {
              return result.resolve.apply(result, res);
            } else {
              return result.resolve(res);
            }
          } catch (_error) {
            err1 = _error;
            if (result.completed()) {
              throw err1;
            } else {
              return result.reject(err1);
            }
          }
        });
      } else {
        this.fail(function(err) {
          return result.reject(err);
        });
      }
      return result;
    };

    Future.prototype["catch"] = function(callback) {

      /*
      Implements 'catch'-samantics to be compatible with standard JS Promise.
      Shortcut for promise.then(undefined, callback)
      @see then()
      @param Function callback function to be evaluated in case of the promise rejection
      @return Future[A]
       */
      return this.then(void 0, callback);
    };

    Future.prototype.catchIf = function(predicate) {

      /*
      Bypasses rejected promise (transform it to the resolved one) if the given predicate function returns true
      @param Function predicate
      @return Future
       */
      return this["catch"](function(err) {
        if (!predicate(err)) {
          throw err;
        }
      });
    };

    Future.prototype.spread = function(onResolved, onRejected) {

      /*
      Like then but expands Array result of the Future to the multiple arguments of the onResolved function call.
       */
      return this.then(function(array) {
        return onResolved.apply(null, array);
      }, onRejected);
    };

    Future.prototype.map = function(callback) {

      /*
      Creates new Future by applying the given callback to the successful result of this Future.
      Resolves resulting future with the result of the callback.
      If callback returns an Array than it's considered as a list of results. If it is necessary to return a single
       array than callback must return an Array with single item containing the resulting Array (Array in Array).
      If this Future is rejected than the resulting Future will contain the same error.
       */
      var result;
      result = Future.single(this._name + " -> map");
      this.done(function() {
        var args, err, mapRes;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        try {
          mapRes = callback.apply(null, args);
          if (_.isArray(mapRes)) {
            return result.resolve.apply(result, mapRes);
          } else {
            return result.resolve(mapRes);
          }
        } catch (_error) {
          err = _error;
          if (result.completed()) {
            throw err;
          } else {
            return result.reject(err);
          }
        }
      });
      this.fail(function(err) {
        return result.reject(err);
      });
      return result;
    };

    Future.prototype.flatMap = function(callback) {

      /*
      Creates new Future by applying the given callback to the successful result of this Future.
      Returns result of the callback as a new Future.
      Callback must return a Future, and resulting Future is completed when the callback-returned future is completed.
      If this Future is rejected than the resulting Future will contain the same error.
      @param Function(this.result -> Future(A)) callback
      @return Future(A)
       */
      var result;
      result = Future.single(this._name + " -> flatMap");
      this.done(function() {
        var args, err;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        try {
          return result.when(callback.apply(null, args));
        } catch (_error) {
          err = _error;
          if (result.completed()) {
            throw err;
          } else {
            return result.reject(err);
          }
        }
      });
      this.fail(function(err) {
        return result.reject(err);
      });
      return result;
    };

    Future.prototype.andThen = function(callback) {

      /*
      Creates and returns a new future with the same result as this future but completed only after invoking
       of the given callback-function. Callback is called on any result of the future.
      Arguments of the callback has the same meaning as always()-callbacks.
      This method allows for establishing order of callbacks.
      @param Function(err, results...) callback
      @return Future(this.result)
       */
      var result;
      result = Future.single(this._name + " -> andThen");
      this["finally"](function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        callback.apply(null, args);
        return result.complete.apply(result, args);
      });
      return result;
    };

    Future.prototype.recover = function(callback) {

      /*
      Returns new future which completes with the result of this future if it's successful or with the result
       of the given callback if this future is failed. Error of the fail result is passed to the callback.
      This method is helpful when it's necessary to convert error of this future to the meaningful successful result.
      @param Function(err -> A) callback
      @return Future[A]
       */
      var result;
      result = Future.single(this._name + " -> recover");
      this.done(function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return result.resolve.apply(result, args);
      });
      this.fail(function(err) {
        var mapRes;
        mapRes = callback.call(null, err);
        if (_.isArray(mapRes)) {
          return result.resolve.apply(result, mapRes);
        } else {
          return result.resolve(mapRes);
        }
      });
      return result;
    };

    Future.prototype.mapFail = function(callback) {

      /*
      Old alias for `recover`
      @deprecated
       */
      return this.recover(callback);
    };

    Future.prototype.recoverWith = function(callback) {

      /*
      Returns new future which completes with the result of this future if it's successful or with the future-result
       of the given callback if this future is failed. Error of the fail result is passed to the callback.
      Callback must return a Future, and resulting Future is completed when the callback-returned future is completed.
      This method is helpful when it's necessary to convert error of this future to the meaningful successful result.
      @param Function(err -> Future(A)) callback
      @return Future[A]
       */
      var result;
      result = Future.single(this._name + " -> recoverWith");
      this.done(function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return result.resolve.apply(result, args);
      });
      this.fail(function(err) {
        return result.when(callback.call(null, err));
      });
      return result;
    };

    Future.prototype.flatMapFail = function(callback) {

      /*
      Old alias for `recoverWith`
      @deprecated
       */
      return this.recoverWith(callback);
    };

    Future.prototype.zip = function() {
      var those;
      those = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /*
      Zips the values of this and that future, and creates a new future holding the tuple of their results.
      If some of the futures have several results that they are represented as array, not "flattened".
      No result represented as undefined value.
      @param Future those another futures
      @return Future
       */
      those.unshift(this);
      return Future.sequence(those, this._name + " -> zip").map(function(result) {
        return result;
      });
    };

    Future.sequence = function(futureList, name) {
      var f, fn1, i, j, len1, promise, result;
      if (name == null) {
        name = ':sequence:';
      }

      /*
      Converts Array[Future[X]] to Future[Array[X]]
       */
      promise = new Future(name);
      result = [];
      fn1 = function(i) {
        promise.fork();
        return f.done(function() {
          var res;
          res = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          result[i] = (function() {
            switch (res.length) {
              case 1:
                return res[0];
              case 0:
                return void 0;
              default:
                return res;
            }
          })();
          return promise.resolve();
        }).fail(function(e) {
          return promise.reject(e);
        });
      };
      for (i = j = 0, len1 = futureList.length; j < len1; i = ++j) {
        f = futureList[i];
        fn1(i);
      }
      return promise.map(function() {
        return [result];
      });
    };

    Future.select = function(futureList) {

      /*
      Returns new future which completes successfully when one of the given futures completes successfully (which comes
       first). Resulting future resolves with that first-completed future's result. All subsequent completing
       futures are ignored.
      Result completes with failure if all of the given futures fails.
      @param Array[Future[X]] futureList
      @return Future[X]
       */
      var f, failCounter, fn1, j, len1, ready, result;
      result = this.single(':select:');
      ready = false;
      failCounter = futureList.length;
      fn1 = function(f) {
        return f.done(function() {
          if (!ready) {
            result.when(f);
            return ready = true;
          }
        }).fail(function() {
          failCounter--;
          if (failCounter === 0) {
            return result.reject("All selecting futures have failed!");
          }
        });
      };
      for (j = 0, len1 = futureList.length; j < len1; j++) {
        f = futureList[j];
        fn1(f);
      }
      return result;
    };

    Future.prototype._runDoneCallbacks = function() {

      /*
      Fires resulting callback functions defined by done with right list of arguments.
       */
      var callbacksCopy;
      this._state = 'resolved';
      callbacksCopy = this._doneCallbacks;
      this._doneCallbacks = [];
      return this._runCallbacks(callbacksCopy, true);
    };

    Future.prototype._runFailCallbacks = function() {

      /*
      Fires resulting callback functions defined by fail with right list of arguments.
       */
      var callbacksCopy;
      callbacksCopy = this._failCallbacks;
      this._failCallbacks = [];
      return this._runCallbacks(callbacksCopy);
    };

    Future.prototype._runAlwaysCallbacks = function() {

      /*
      Fires resulting callback functions defined by always with right list of arguments.
       */
      var args, callback, callbacksCopy, i, j, k, len, len1, ref, results;
      if (this._state === 'pending') {
        this._state = 'resolved';
      }
      callbacksCopy = this._alwaysCallbacks;
      this._alwaysCallbacks = [];
      this._completed = true;
      args = [];
      if (this._state === 'resolved') {
        args.push(null);
        if (this._callbackArgs != null) {
          len = this._order > 0 ? this._order : this._callbackArgs.length;
          for (i = j = 0, ref = len - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            args = args.concat(this._callbackArgs[i]);
          }
        }
      } else {
        args = this._callbackArgs;
      }
      results = [];
      for (k = 0, len1 = callbacksCopy.length; k < len1; k++) {
        callback = callbacksCopy[k];
        results.push(callback.apply(null, args));
      }
      return results;
    };

    Future.prototype._runCallbacks = function(callbacks, flattenArgs) {
      var args, callback, i, j, k, l, len, len1, len2, ref, results, results1;
      if (flattenArgs == null) {
        flattenArgs = false;
      }

      /*
      Helper-method to run list of callbacks.
      @param Array(Function) callbacks
       */
      this._completed = true;
      if (this._callbackArgs != null) {
        args = [];
        if (flattenArgs) {
          len = this._order > 0 ? this._order : this._callbackArgs.length;
          for (i = j = 0, ref = len - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            args = args.concat(this._callbackArgs[i]);
          }
        } else {
          args = this._callbackArgs;
        }
        results = [];
        for (k = 0, len1 = callbacks.length; k < len1; k++) {
          callback = callbacks[k];
          results.push(callback.apply(null, args));
        }
        return results;
      } else {
        results1 = [];
        for (l = 0, len2 = callbacks.length; l < len2; l++) {
          callback = callbacks[l];
          results1.push(callback());
        }
        return results1;
      }
    };

    Future.single = function(name) {
      if (name == null) {
        name = ':single:';
      }

      /*
      Returns the future, which can not be forked and must be resolved by only single call of resolve().
      @return Future
       */
      return (new Future(1, name)).lock();
    };

    Future.resolved = function() {
      var args, result;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /*
      Returns the future already resolved with the given arguments.
      @return Future
       */
      result = this.single(':resolved:');
      result.resolve.apply(result, args);
      return result;
    };

    Future.rejected = function(error) {

      /*
      Returns the future already rejected with the given error
      @param Any error
      @return Future
       */
      var result;
      result = this.single(':rejected:');
      result.reject(error);
      return result;
    };

    Future.call = function() {
      var args, err, fn, result;
      fn = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];

      /*
      Converts node-style function call with last-agrument-callback result to pretty composable future-result call.
      Node-style callback mean Function[err, A] - first argument if not-null means error and converts to
       Future.reject(), all subsequent arguments are treated as a successful result and passed to Future.resolve().
      Example:
        Traditional style:
          fs.readFile '/tmp/file', (err, data) ->
            throw err if err
            // do something with data
        Future-style:
          Future.call(fs.readFile, '/tmp/file').failAloud().done (data) ->
            // do something with data
      @param Function|Tuple[Object, String] fn callback-style function to be called (e.g. fs.readFile)
      @param Any args* arguments of that function without last callback-result argument.
      @return Future[A]
       */
      result = this.single(":call:(" + fn.name + ")");
      args.push(function() {
        var callbackArgs;
        callbackArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return result.complete.apply(result, callbackArgs);
      });
      try {
        if (_.isArray(fn)) {
          fn[0][fn[1]].apply(fn[0], args);
        } else {
          fn.apply(null, args);
        }
      } catch (_error) {
        err = _error;
        result.reject(err);
      }
      return result;
    };

    Future.timeout = function(millisec) {

      /*
      Returns the future wich will complete after the given number of milliseconds
      @param Int millisec number of millis before resolving the future
      @return Future
       */
      var result;
      result = this.single(":timeout:(" + millisec + ")");
      setTimeout(function() {
        return result.resolve();
      }, millisec);
      return result;
    };

    Future.require = function() {
      var paths, requirejs, result;
      paths = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /*
      Convenient Future-wrapper for requirejs's require call.
      @param String* paths list of modules requirejs-format paths
      @return Future(modules...)
       */
      if (paths.length === 1 && _.isArray(paths[0])) {
        paths = paths[0];
      }
      result = this.single(':require:(' + paths.join(', ') + ')');
      requirejs = require(process.cwd() + '/node_modules/requirejs');
      requirejs(paths, function() {
        var err, modules;
        modules = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        try {
          return result.resolve.apply(result, modules);
        } catch (_error) {
          err = _error;
          console.error("Got exception in Future.require() callbacks for [" + result._name + "]: " + err, err);
          return console.log(err.stack);
        }
      }, function(err) {
        return result.reject(err);
      });
      return result;
    };

    Future["try"] = function(fn) {

      /*
      Wraps synchronous function result into resolved or rejected Future depending if the function throws an exception
      @param Function fn function to be called
      @return Future if the argument function throws exception than Future.rejected with that exception is returned
                     if the argument function returns a Future than it is returned as-is
                     otherwise Future.resolved with the function result is returned
       */
      var err, res;
      try {
        res = fn();
        if (res instanceof Future) {
          return res;
        } else {
          return Future.resolved(res);
        }
      } catch (_error) {
        err = _error;
        return Future.rejected(err);
      }
    };

    Future.prototype._initDebugTimeout = function() {
      var ref, timeout;
      timeout = (ref = global.config) != null ? ref.debug.future.timeout : void 0;
      if (timeout > 0) {
        return this._incompleteTimeout = setTimeout((function(_this) {
          return function() {
            if (_this.state() === 'pending' && _this._counter > 0) {
              return console.warn("Future timed out [" + _this._name + "] (" + (timeout / 1000) + " seconds), counter = " + _this._counter);
            }
          };
        })(this), timeout);
      }
    };

    Future.prototype._clearDebugTimeout = function() {
      if (this._incompleteTimeout != null) {
        clearTimeout(this._incompleteTimeout);
        return this._incompleteTimeout = null;
      }
    };

    Future.prototype._clearDoneCallbacks = function() {
      return this._doneCallbacks = [];
    };

    Future.prototype._clearFailCallbacks = function() {
      return this._failCallbacks = [];
    };

    Future.prototype.clear = function() {

      /*
      Way to eliminate any impact of resolving or rejecting or time-outing of this promise.
      Should be used when actions that are waiting for this promise completion are no more needed.
       */
      this._clearDoneCallbacks();
      this._clearFailCallbacks();
      this._alwaysCallbacks = [];
      return this._clearDebugTimeout();
    };

    Future.prototype._debug = function() {
      var args, fn;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /*
      Debug logging method, which logs future's name, counter, callback lenght, and given arguments.
      Can emphasise futures with desired names by using console.warn.
       */
      if (this._name.indexOf('desired search in name') !== -1) {
        fn = console.warn;
      } else {
        fn = console.log;
      }
      args.unshift(this._name);
      args.unshift(this._doneCallbacks.length);
      args.unshift(this._counter);
      return fn.apply(console, args);
    };

    return Future;

  })();
};

module.exports = defineFuture(require('underscore'));
