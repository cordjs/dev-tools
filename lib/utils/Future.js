// Generated by CoffeeScript 1.9.1
var defineFuture,
  slice = [].slice;

defineFuture = function(_, asapInContext) {
  var Future, addCallbackToQueue, asapDoneCb, asapFailCb, capacity, cons, currentContextPromise, errorObj, failAloudCb, filterStack, finallyDoneCb, finallyFailCb, flushCallbackQueue, initTimeoutTracker, longStackTraceAppendName, longStackTraceEnabled, preallocatedResolvedEmptyPromise, recCollectLongStackTrace, ref, ref1, ref2, ref3, splitAndRawFilterStack, thenHandleCb, tryCatch, tryCatchTarget, tryCatcher, unhandledMap, unhandledSoftTracking, unhandledTrackingEnabled, unresolvedMap, unresolvedTrackingEnabled;
  unhandledTrackingEnabled = false;
  unhandledSoftTracking = false;
  unhandledMap = null;
  unresolvedTrackingEnabled = false;
  unresolvedMap = null;
  longStackTraceEnabled = false;
  currentContextPromise = null;
  cons = function() {
    if (typeof _console !== 'undefined') {
      return _console;
    } else {
      return console;
    }
  };
  Future = (function() {

    /*
    Home-grown promise implementation (reinvented the wheel)
     */
    Future.prototype._counter = 0;

    Future.prototype._doneCallbacks = null;

    Future.prototype._failCallbacks = null;

    Future.prototype._settledValue = void 0;

    Future.prototype._locked = false;

    Future.prototype._completed = false;

    Future.prototype._state = 'pending';

    Future.prototype._name = '';

    Future.prototype._parent = null;

    function Future(initialCounter, name) {
      if (initialCounter == null) {
        initialCounter = 0;
      }
      if (name == null) {
        name = ':noname:';
      }

      /*
      @param (optional)Int initialCounter initial state of counter, syntax sugar to avoid (new Future).fork().fork()
      @param (optional)String name individual name of the future to separate it from others during debugging
       */
      if ((initialCounter != null) && _.isString(initialCounter)) {
        name = initialCounter;
        initialCounter = 0;
      }
      this._counter = initialCounter;
      this._doneCallbacks = [];
      this._failCallbacks = [];
      this._name = name;
      if (longStackTraceEnabled) {
        this._stack = (new Error).stack;
        if (currentContextPromise) {
          this._parent = currentContextPromise;
        }
      }
      if (unresolvedTrackingEnabled) {
        this._initDebugTimeout();
      }
      if (unhandledTrackingEnabled) {
        this._initUnhandledTracking();
      }
    }

    Future.prototype.name = function(nameSuffix) {

      /*
      Appends name suffix to this promise's name. Useful for debugging when there is no API to set name another way.
      Returns this promise, so can be used in call-chains.
      @param {String} nameSuffix
      @return {Future} this
       */
      if (this._name === '' || this._name === ':noname:') {
        this._name = nameSuffix;
      } else {
        this._name += " [" + nameSuffix + "]";
      }
      return this;
    };

    Future.prototype.rename = function(name) {

      /*
      Renames current future
       */
      this._name = name;
      return this;
    };

    Future.prototype.fork = function() {

      /*
      Adds one more value to wait.
      Should be paired with following resolve() call.
      @return Future(self)
       */
      if (this._completed && !(this._state === 'rejected' && this._counter > 0)) {
        throw new Error("Trying to use the completed future [" + this._name + "]!");
      }
      if (this._locked) {
        throw new Error("Trying to fork locked future [" + this._name + "]!");
      }
      this._counter++;
      return this;
    };

    Future.prototype.resolve = function(value) {

      /*
      Indicates that one of the waiting values is ready.
      If there are some arguments passed then they are passed unchanged to the done-callbacks.
      If there is no value remaining in the aggregate and done method is already called
       than callback is fired immediately.
      Should have according fork() call before.
       */
      var nameStr;
      if (this._counter > 0) {
        this._counter--;
        if (this._state !== 'rejected' && this._doneCallbacks) {
          this._settledValue = value;
          if (this._counter === 0) {
            if (this._locked) {
              this._state = 'resolved';
            }
            if (unhandledSoftTracking && this._locked) {
              this._clearUnhandledTracking();
            }
            if (this._doneCallbacks.length > 0) {
              this._runDoneCallbacks();
            }
            if (this._state === 'resolved') {
              this._clearFailCallbacks();
            }
            if (unresolvedTrackingEnabled) {
              this._clearDebugTimeout();
            }
          }
        }
      } else {
        nameStr = this._name ? " (name = " + this._name + ")" : '';
        throw new Error("Future::resolve() is called more times than Future::fork!" + nameStr + " state = " + this._state + ", [" + this._settledValue + "]");
      }
      return this;
    };

    Future.prototype.reject = function(reason) {

      /*
      Indicates that the promise is rejected (failed) and fail-callbacks should be called.
      If there are some arguments passed then they are passed unchanged to the fail-callbacks.
      If fail-method is already called than callbacks are fired immediately, otherwise they'll be fired
       when fail-method is called.
      Only first call of this method is important. Any subsequent calls does nothing but decrementing the counter.
       */
      if (this._counter > 0) {
        this._counter--;
        if (this._state !== 'rejected' && this._failCallbacks) {
          this._state = 'rejected';
          this._settledValue = reason != null ? reason : new Error("Future[" + this._name + "] rejected without error message!");
          this._clearDoneCallbacks();
          if (this._failCallbacks.length > 0) {
            this._runFailCallbacks();
          }
          if (unresolvedTrackingEnabled) {
            this._clearDebugTimeout();
          }
        }
      } else {
        throw new Error("Future::reject is called more times than Future::fork! [" + this._name + "], state = " + this._state + ", [" + this._settledValue + "]");
      }
      return this;
    };

    Future.prototype.complete = function(err, value) {

      /*
      Completes this promise either with successful of failure result depending on the arguments.
      If first argument is not null than the promise is completed with reject using first argument as an error.
      Otherwise remaining arguments are used for promise.resolve() call.
      This method is useful to work with lots of APIs using such semantics of the callback agruments.
       */
      if (err != null) {
        return this.reject(err);
      } else {
        return this.resolve(value);
      }
    };

    Future.prototype.when = function() {

      /*
      Adds another future(promise)(s) as a condition of completion of this future
      Can be called multiple times.
      @param (variable)Future args another future which'll be waited
      @return Future self
      @todo maybe need to support noTimeout property of futureList promises
       */
      var j, len1, promise, ref, self;
      self = this;
      for (j = 0, len1 = arguments.length; j < len1; j++) {
        promise = arguments[j];
        if (!this._locked) {
          this.fork();
        }
        if (promise._noTimeout || !((ref = global.config) != null ? ref.debug.future.trackInternalTimeouts : void 0)) {
          self.withoutTimeout();
        }
        promise._done(this.resolve, this)._fail(this.reject, this);
      }
      return this;
    };

    Future.prototype.link = function(anotherPromise) {

      /*
      Inversion of `when` method. Tells that the given future will complete when this future will complete.
      Just syntax sugar to convert anotherFuture.when(future) to future.link(anotherFuture).
      In some cases using link instead of when leads to more elegant code.
      @param Future anotherFuture
      @return Future self
       */
      anotherPromise.when(this);
      return this;
    };

    Future.prototype.done = function(callback) {

      /*
      Defines callback function to be called when future is resolved.
      If all waiting values are already resolved then callback is fired immedialtely.
      If done method is called several times than all passed functions will be called.
       */
      return this._done(callback);
    };

    Future.prototype._done = function(cb, ctx, arg) {

      /*
      Appends given callback to the resolved task queue and triggers its execution asynchronously if needed.
       */
      if (this._state !== 'rejected' && this._doneCallbacks) {
        addCallbackToQueue(this._doneCallbacks, cb, ctx, arg);
        if (this._counter === 0 && (this._doneCallbacks.length === 3 || this._state === 'pending')) {
          if (unresolvedTrackingEnabled) {
            this._clearDebugTimeout();
          }
          asapInContext(this, asapDoneCb);
        }
      }
      return this;
    };

    Future.prototype.fail = function(callback) {

      /*
      Defines callback function to be called when future is rejected.
      If all waiting values are already resolved then callback is fired immedialtely.
      If fail method is called several times than all passed functions will be called.
       */
      if (!_.isFunction(callback)) {
        throw new Error("Invalid argument for Future.fail(): " + callback + ". [" + this._name + "]");
      }
      return this._fail(callback);
    };

    Future.prototype._fail = function(cb, ctx, arg) {

      /*
      Appends given callback to the failed task queue and triggers its execution asynchronously if needed.
       */
      if (this._state !== 'resolved' && this._failCallbacks) {
        addCallbackToQueue(this._failCallbacks, cb, ctx, arg);
        if (this._state === 'rejected' && this._failCallbacks.length === 3) {
          if (unresolvedTrackingEnabled) {
            this._clearDebugTimeout();
          }
          asapInContext(this, asapFailCb);
        }
      }
      if (unhandledTrackingEnabled) {
        this._clearUnhandledTracking();
      }
      return this;
    };

    Future.prototype["finally"] = function(callback) {

      /*
      Defines callback function to be called when future is completed by any mean.
      Callback arguments are using popular semantics with first-argument-as-an-error (Left) and other arguments
       are successful results of the future.
      Returns a new promise completed with this promise result (successful or rejected) after the callback is executed.
      Unlike `then` the callback cannot modify the resulting value with one exception:
       if the callback throws error then the resulting promise is rejected with that error.
      @param {Function} callback
      @return {Future<Any>}
       */
      var ref, result;
      result = Future.single(this._name + " -> finally");
      if (this._noTimeout || !((ref = global.config) != null ? ref.debug.future.trackInternalTimeouts : void 0)) {
        result.withoutTimeout();
      }
      this._done(finallyDoneCb, result, callback);
      this._fail(finallyFailCb, result, callback);
      if (unhandledTrackingEnabled && callback.length > 0) {
        this._clearUnhandledTracking();
      }
      return result;
    };

    Future.prototype.failAloud = function(message) {

      /*
      Adds often-used scenario of fail that just loudly reports the error
       */
      return this._fail(failAloudCb, this, message);
    };

    Future.prototype.failOk = function() {

      /*
      Registers empty fail handler for the Future to prevent it to be reported in unhandled failure tracking.
      This method is useful when the failure result is expected and it's OK not to handle it.
       */
      return this._fail(_.noop);
    };

    Future.prototype.completed = function() {

      /*
      Indicates that callbacks() are already called at least once and fork() cannot be called anymore
      @return Boolean
       */
      if (!this._completed && this._counter === 0) {
        this._completed = true;
      }
      return this._completed;
    };

    Future.prototype.pending = function() {

      /*
      Indicates, that current Future now in pending state
      Syntax sugar for state() == 'pending'
       */
      return this.state() === 'pending';
    };

    Future.prototype.state = function() {

      /*
      Returns state of the promise - 'pending', 'resolved' or 'rejected'
      @return String
       */
      return this._state;
    };

    Future.prototype.lock = function() {
      this._locked = true;
      return this;
    };

    Future.prototype.then = function(onResolved, onRejected, _nameSuffix) {
      var ref, result;
      if (_nameSuffix == null) {
        _nameSuffix = 'then';
      }

      /*
      Implements 'then'-semantics to be compatible with standard JS Promise.
      Both arguments are optional but at least on of them must be defined!
      @param (optional)Function onResolved callback to be evaluated in case of successful resolving of the promise
                                           If the Future returned then it's result is proxied to the then-result Future.
                                           Returned Array is spread into same number of callback arguments.
                                           If exception is thrown then it's wrapped into rejected Future and returned.
                                           Any other return value is just returned wrappend into resulting Future.
      @param (optional)Function onRejected callback to be evaluated in case of the promise rejection
                                           This is the same as using catch() method.
                                           Return value behaviour is the same as for `onResolved` callback
      @return Future[A]
       */
      if ((onResolved == null) && (onRejected == null)) {
        _nameSuffix = 'then(empty)';
      }
      result = Future.single(this._name + " -> " + _nameSuffix);
      if (this._noTimeout || !((ref = global.config) != null ? ref.debug.future.trackInternalTimeouts : void 0)) {
        result.withoutTimeout();
      }
      if (typeof onResolved === 'function') {
        this._done(thenHandleCb, result, onResolved);
      } else {
        this._done(this.resolve, result);
      }
      if (typeof onRejected === 'function') {
        this._fail(thenHandleCb, result, onRejected);
      } else {
        this._fail(this.reject, result);
      }
      return result;
    };

    Future.prototype["catch"] = function(callback) {

      /*
      Implements 'catch'-semantics to be compatible with standard JS Promise.
      Shortcut for promise.then(undefined, callback)
      @see then()
      @param Function callback function to be evaluated in case of the promise rejection
      @return Future[A]
       */
      return this.then(void 0, callback, 'catch');
    };

    Future.prototype.catchIf = function(predicate, callback) {

      /*
      Catch error only if predicate returns true. On catch calls callback, if specified.
      If predicate instance of Error, then error catched only of error instanceof predicate
      @param Function predicate
      @return Future
       */
      if (!_.isFunction(predicate)) {
        return Future.rejected(new Error("Invalid predicate"));
      }
      if (predicate.prototype instanceof Error) {
        (function(_this) {
          return (function(errorClass) {
            return predicate = function(e) {
              return e instanceof errorClass;
            };
          });
        })(this)(predicate);
      }
      return this["catch"](function(err) {
        if (predicate(err)) {
          return typeof callback === "function" ? callback(err) : void 0;
        } else {
          throw err;
        }
      });
    };

    Future.prototype.spread = function(onResolved, onRejected) {

      /*
      Like then but expands Array result of the Future to the multiple arguments of the onResolved function call.
       */
      return this.then(function(array) {
        return onResolved.apply(null, array);
      }, onRejected);
    };

    Future.all = function(futureList, name) {
      var f, fn1, i, j, len1, promise, result;
      if (name == null) {
        name = ':all:';
      }

      /*
      Converts Array<Thenable<Any>|Any> to Future<Array<Any>>
      If the given array's element is thenable then it's eventual resolved value is put to the result array,
       otherwise the element is passed to the result array as-is.
      @param {Array<Any>} futureList
      @param {String} name - result promise debug name
      @return {Future<Array<Any>>}
      @todo maybe need to support noTimeout property of futureList promises
       */
      promise = new Future(name);
      result = [];
      fn1 = function(i) {
        if (f && typeof f.then === 'function') {
          promise.fork();
          return f.then(function(res) {
            result[i] = res;
            return promise.resolve();
          }, function(e) {
            return promise.reject(e);
          });
        } else {
          return result[i] = f;
        }
      };
      for (i = j = 0, len1 = futureList.length; j < len1; i = ++j) {
        f = futureList[i];
        fn1(i);
      }
      return promise.then(function() {
        return result;
      });
    };

    Future.any = function(futureList) {

      /*
      Returns new future which completes successfully when one of the given futures completes successfully (which comes
       first). Resulting future resolves with that first-completed future's result. All subsequent completing
       futures are ignored.
      Result completes with failure if all of the given futures fails.
      @param {Array<Future<Any>>} futureList
      @return {Future<Any>}
      @todo maybe need to support noTimeout property of futureList promises
       */
      var f, failCounter, j, len1, ready, result;
      result = this.single(':race:');
      ready = false;
      failCounter = futureList.length;
      for (j = 0, len1 = futureList.length; j < len1; j++) {
        f = futureList[j];
        f.done(function(value) {
          if (!ready) {
            ready = true;
            return result.resolve(value);
          }
        }).fail(function(err) {
          failCounter--;
          if (failCounter === 0) {
            return result.reject(err);
          }
        });
      }
      return result;
    };

    Future.prototype._runDoneCallbacks = function() {

      /*
      Triggers execution of onResolved callbacks waiting for this promise.
       */
      this._state = 'resolved';
      if (unhandledSoftTracking && !this._locked) {
        this._clearUnhandledTracking();
      }
      return flushCallbackQueue(this._doneCallbacks, this._settledValue);
    };

    Future.prototype._runFailCallbacks = function() {

      /*
      Triggers execution of onRejected callbacks waiting for this promise.
       */
      return flushCallbackQueue(this._failCallbacks, this._settledValue);
    };

    Future.single = function(name) {
      if (name == null) {
        name = ':single:';
      }

      /*
      Returns the future, which can not be forked and must be resolved by only single call of resolve().
      @return Future
       */
      return (new Future(1, name)).lock();
    };

    Future.resolved = function(value) {

      /*
      Returns the future already resolved with the given arguments.
      @return Future
       */
      if (value !== void 0) {
        return this.single(':resolved:').resolve(value);
      } else {
        return preallocatedResolvedEmptyPromise;
      }
    };

    Future.rejected = function(error) {

      /*
      Returns the future already rejected with the given error
      @param Any error
      @return Future
       */
      var result;
      result = this.single(':rejected:');
      result.reject(error);
      return result;
    };

    Future.call = function() {
      var args, err, fn, result;
      fn = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];

      /*
      Converts node-style function call with last-agrument-callback result to pretty composable future-result call.
      Node-style callback mean Function[err, A] - first argument if not-null means error and converts to
       Future.reject(), all subsequent arguments are treated as a successful result and passed to Future.resolve().
      Example:
        Traditional style:
          fs.readFile '/tmp/file', (err, data) ->
            throw err if err
            // do something with data
        Future-style:
          Future.call(fs.readFile, '/tmp/file').failAloud().done (data) ->
            // do something with data
      @param Function|Tuple[Object, String] fn callback-style function to be called (e.g. fs.readFile)
      @param Any args* arguments of that function without last callback-result argument.
      @return Future[A]
       */
      result = this.single(":call:(" + fn.name + ")");
      args.push(function() {
        if (!result.completed()) {
          return result.complete.apply(result, arguments);
        }
      });
      try {
        if (_.isArray(fn)) {
          fn[0][fn[1]].apply(fn[0], args);
        } else {
          fn.apply(null, args);
        }
      } catch (_error) {
        err = _error;
        if (!result.completed()) {
          result.reject(err);
        }
      }
      return result;
    };

    Future.timeout = function(millisec) {

      /*
      Returns the future wich will complete after the given number of milliseconds
      @param Int millisec number of millis before resolving the future
      @return Future
       */
      var result;
      result = this.single(":timeout:(" + millisec + ")");
      setTimeout(function() {
        return result.resolve();
      }, millisec);
      return result;
    };

    Future.require = function() {
      var paths, requirejs, result;
      paths = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /*
      Convenient Future-wrapper for requirejs's require call.
      Returns promise with single module if single module is requested and promise with array of modules otherwise.
      @param {String*|Array<String>} paths - list of modules requirejs-format paths
      @return {Future<Any>} or {Future<Array<Any>>}
       */
      if (paths.length === 1 && _.isArray(paths[0])) {
        paths = paths[0];
      }
      result = this.single(':require:(' + paths.join(', ') + ')');
      requirejs = require(process.cwd() + '/node_modules/requirejs');
      requirejs(paths, function() {
        var err;
        try {
          return result.resolve(arguments.length === 1 ? arguments[0] : Array.prototype.slice.call(arguments, 0));
        } catch (_error) {
          err = _error;
          return cons().error("Got exception in Future.require() callbacks for [" + result._name + "]:", err);
        }
      }, function(err) {
        return result.reject(err);
      });
      return result;
    };

    Future["try"] = function(fn) {

      /*
      Wraps synchronous function result into resolved or rejected Future depending if the function throws an exception
      @param Function fn function to be called
      @return Future if the argument function throws exception than Future.rejected with that exception is returned
                     if the argument function returns a Future than it is returned as-is
                     otherwise Future.resolved with the function result is returned
       */
      var err, res;
      try {
        res = fn();
        if (res instanceof Future) {
          return res;
        } else {
          return Future.resolved(res);
        }
      } catch (_error) {
        err = _error;
        return Future.rejected(err);
      }
    };

    Future.prototype.withoutTimeout = function() {

      /*
      Mark that Future's normal behaviour is to wait forever
      For instance a Future that depends on user's input
       */
      if (unresolvedTrackingEnabled) {
        this._clearDebugTimeout();
      }
      this._noTimeout = true;
      return this;
    };

    Future.prototype._initDebugTimeout = function() {
      this._trackId || (this._trackId = _.uniqueId());
      return unresolvedMap[this._trackId] = {
        startTime: (new Date).getTime(),
        promise: this
      };
    };

    Future.prototype._clearDebugTimeout = function() {
      return delete unresolvedMap[this._trackId];
    };

    Future.prototype._clearDoneCallbacks = function() {
      return this._doneCallbacks = null;
    };

    Future.prototype._clearFailCallbacks = function() {
      return this._failCallbacks = null;
    };

    Future.prototype.clear = function() {

      /*
      Way to eliminate any impact of resolving or rejecting or time-outing of this promise.
      Should be used when actions that are waiting for this promise completion are no more needed.
       */
      if (this === preallocatedResolvedEmptyPromise) {
        return;
      }
      this._clearDoneCallbacks();
      this._clearFailCallbacks();
      if (unresolvedTrackingEnabled) {
        this._clearDebugTimeout();
      }
      if (unhandledTrackingEnabled) {
        this._clearUnhandledTracking();
      }
    };

    Future.prototype.toJSON = function() {

      /*
      Serialization of promises is not supported.
       */
      return null;
    };

    Future.prototype._initUnhandledTracking = function() {

      /*
      Registers the promise to the unhandled failure tracking map.
       */
      this._trackId || (this._trackId = _.uniqueId());
      return unhandledMap[this._trackId] = {
        startTime: (new Date).getTime(),
        promise: this
      };
    };

    Future.prototype._clearUnhandledTracking = function() {

      /*
      Removes the promise from the unhandled failure tracking map.
      Should be called when failure handling callback is registered.
       */
      return delete unhandledMap[this._trackId];
    };

    Future.prototype._debug = function() {
      var args, fn;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /*
      Debug logging method, which logs future's name, counter, callback length, and given arguments.
      Can emphasise futures with desired names by using console.warn.
       */
      if (this._name.indexOf('desired search in name') !== -1) {
        fn = cons().warn;
      } else {
        fn = cons().log;
      }
      args.unshift(this._name);
      args.unshift(this._doneCallbacks.length);
      args.unshift(this._counter);
      return fn.apply(cons, args);
    };

    return Future;

  })();
  errorObj = {
    e: {}
  };
  tryCatchTarget = void 0;
  tryCatcher = function() {
    var e;
    try {
      return tryCatchTarget.apply(this, arguments);
    } catch (_error) {
      e = _error;
      errorObj.e = e;
      return errorObj;
    }
  };
  tryCatch = function(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  };
  asapDoneCb = function() {
    this._clearFailCallbacks();
    return this._runDoneCallbacks();
  };
  asapFailCb = function() {
    return this._runFailCallbacks();
  };
  failAloudCb = function(err, message) {
    var reportArgs;
    reportArgs = ["Future(" + this._name + ")::failAloud" + (message ? " with message: " + message : '')];
    if (err) {
      reportArgs.push("\n" + err);
      reportArgs.push("\n" + filterStack(err.stack));
    }
    if (this._stack) {
      reportArgs.push("\n---------------");
      recCollectLongStackTrace(this, reportArgs);
    }
    return cons().error.apply(cons(), reportArgs);
  };
  thenHandleCb = function(value, fn) {
    var prevContextPromise, res;
    prevContextPromise = currentContextPromise;
    currentContextPromise = this;
    res = tryCatch(fn).call(null, value);
    currentContextPromise = prevContextPromise;
    if (res === errorObj) {
      if (this.completed()) {
        throw res.e;
      } else {
        this.reject(res.e);
      }
    } else if (res instanceof Future) {
      this.when(res);
    } else if (res && typeof res.then === 'function') {
      res.then((function(_this) {
        return function(value) {
          return _this.resolve(value);
        };
      })(this), (function(_this) {
        return function(reason) {
          return _this.reject(reason);
        };
      })(this));
    } else if (_.isArray(res)) {
      if (res.length === 1 && _.isArray(res[0])) {
        cons().warn("DEPRECATION WARNING: returning of array in array as 'then' callback result hack detected for promise with name '" + this._name + "'. This behaviour is deprecated, return just array without any wrapper!", this._stack);
        res = res[0];
      }
      this.resolve(res);
    } else {
      this.resolve(res);
    }
  };
  finallyDoneCb = function(value, fn) {
    var prevContextPromise, res;
    prevContextPromise = currentContextPromise;
    currentContextPromise = this;
    res = tryCatch(fn).call(null, null, value);
    currentContextPromise = prevContextPromise;
    if (res === errorObj) {
      if (this.completed()) {
        throw res.e;
      } else {
        this.reject(res.e);
      }
    } else {
      this.resolve(value);
    }
  };
  finallyFailCb = function(reason, fn) {
    var prevContextPromise, res;
    prevContextPromise = currentContextPromise;
    currentContextPromise = this;
    res = tryCatch(fn).call(null, reason);
    currentContextPromise = prevContextPromise;
    if (res === errorObj) {
      if (this.completed()) {
        throw res.e;
      } else {
        this.reject(res.e);
      }
    } else {
      if (unhandledTrackingEnabled) {
        this._clearUnhandledTracking();
      }
      this.reject(reason);
    }
  };
  addCallbackToQueue = function(queue, fn, ctx, passArg) {

    /*
    DRY method adding task to the given task queue
     */
    queue[queue.length] = fn;
    queue[queue.length] = ctx;
    queue[queue.length] = passArg;
  };
  capacity = 1024;
  flushCallbackQueue = function(queue, settledValue) {

    /*
    Executes all tasks from the given queue.
    Task - three consequent elements of the array interpreted as:
     * first - the callback function
     * second - the context object for which function should be called (can be empty)
     * third - any additional argument passed to the callback function as a second argument after the given settledValue
    During execution new tasks may be appended to the queue by the previous tasks, they are also executed.
    At the end the task queue is cleaned.
    The technique is copied from the asap library.
    @param {Array} queue
    @param {Any} settledValue - the resulting value of the promise (success or failure)
     */
    var currentIndex, index, len, scan;
    index = 0;
    while (index < queue.length) {
      currentIndex = index;
      index += 3;
      queue[currentIndex].call(queue[currentIndex + 1], settledValue, queue[currentIndex + 2]);
      if (index > capacity) {
        scan = 0;
        len = queue.length - index;
        while (scan < len) {
          queue[scan] = queue[scan + index];
          scan++;
        }
        queue.length -= index;
        index = 0;
      }
    }
    queue.length = 0;
  };
  splitAndRawFilterStack = function(stackStr) {

    /*
    @param {String} stackArr
    @return {Array<String>}
     */
    return stackStr.split("\n").slice(1).filter(function(x) {
      return x.indexOf('Future.js') === -1 && x.indexOf('require.js') === -1 && x.indexOf('/r.js') === -1 && x.indexOf('raw.js') === -1;
    });
  };
  filterStack = function(stackStr, promiseName, parentStackStr) {

    /*
    Beautifies and returns given stack-trace string.
    Filters Future.js and require.js lines. Also filters lines intersecting with the parent promise stack trace.
    @param {String} stackStr
    @param {String} promiseName
    @param {String} parentStackStr
    @return {String}
     */
    var parentStackArr, stackArr;
    stackArr = splitAndRawFilterStack(stackStr);
    if (parentStackStr) {
      parentStackArr = splitAndRawFilterStack(parentStackStr);
      stackArr = _.difference(stackArr, parentStackArr);
    }
    return stackArr.map(function(x) {
      return x + (longStackTraceAppendName && promiseName ? " [" + promiseName + "]" : '');
    }).join("\n");
  };
  recCollectLongStackTrace = function(promise, args) {

    /*
    Recursively collects beautified long stack-trace for the hierarhy of promises into the given args array.
    @param {Future} promise
    @param {Array} args
     */
    var ref;
    if (promise._stack) {
      args.push("\n" + filterStack(promise._stack, promise._name, (ref = promise._parent) != null ? ref._stack : void 0));
    }
    if (promise._parent) {
      recCollectLongStackTrace(promise._parent, args);
    }
  };
  initTimeoutTracker = function() {

    /*
    Initializes infinite checking of promises with unhandled failure result.
     */
    var interval, ref, ref1, ref2, ref3, unhandledTimeout, unresolvedTimeout;
    unhandledSoftTracking = !!((ref = global.config) != null ? ref.debug.future.trackUnhandled.soft : void 0);
    interval = parseInt((ref1 = global.config) != null ? ref1.debug.future.trackUnhandled.interval : void 0);
    unhandledTimeout = parseInt((ref2 = global.config) != null ? ref2.debug.future.trackUnhandled.timeout : void 0);
    unresolvedTimeout = parseInt((ref3 = global.config) != null ? ref3.debug.future.timeout : void 0);
    unhandledMap = {};
    unresolvedMap = {};
    if (interval > 0) {
      return setInterval(function() {
        var curTime, elapsed, err, id, info, pr, reportArgs, results, state;
        curTime = (new Date).getTime();
        for (id in unresolvedMap) {
          info = unresolvedMap[id];
          elapsed = curTime - info.startTime;
          if (elapsed > unresolvedTimeout) {
            pr = info.promise;
            if (pr.state() === 'pending' && pr._counter > 0) {
              reportArgs = ["Future timed out [" + pr._name + "] (" + (elapsed / 1000) + " seconds), counter = " + pr._counter];
              if (pr._stack) {
                reportArgs.push("\n" + filterStack(pr._stack));
              }
              recCollectLongStackTrace(info.promise, reportArgs);
              cons().warn.apply(cons(), reportArgs);
            }
            delete unresolvedMap[id];
          }
        }
        results = [];
        for (id in unhandledMap) {
          info = unhandledMap[id];
          elapsed = curTime - info.startTime;
          if (elapsed > unhandledTimeout) {
            state = info.promise.state();
            if (state !== 'pending') {
              reportArgs = [("Unhandled rejection detected for [" + state + "] Future[" + info.promise._name + "] ") + ("after " + (elapsed / 1000) + " seconds!")];
              if (state === 'rejected') {
                err = info.promise._settledValue;
                reportArgs.push("\n" + err);
                if (err.stack) {
                  reportArgs.push("\n" + filterStack(err.stack));
                }
                recCollectLongStackTrace(info.promise, reportArgs);
              }
              cons().warn.apply(cons(), reportArgs);
            }
            results.push(delete unhandledMap[id]);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }, interval);
    }
  };
  longStackTraceEnabled = !!((ref = global.config) != null ? ref.debug.future.longStackTrace.enable : void 0);
  longStackTraceAppendName = !!((ref1 = global.config) != null ? ref1.debug.future.longStackTrace.appendPromiseName : void 0);
  unhandledTrackingEnabled = !!((ref2 = global.config) != null ? ref2.debug.future.trackUnhandled.enable : void 0);
  unresolvedTrackingEnabled = !!((ref3 = global.config) != null ? ref3.debug.future.timeout : void 0);
  if (unhandledTrackingEnabled || unresolvedTrackingEnabled) {
    initTimeoutTracker();
  }
  preallocatedResolvedEmptyPromise = Future.single(':empty:').resolve();
  return Future;
};

module.exports = defineFuture(require('underscore'), require('./asapInContext'));
