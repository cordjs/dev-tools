// Generated by CoffeeScript 1.9.1
(function(factory) {
  var isBrowser, rootCtx;
  isBrowser = typeof window !== 'undefined' && window.document;
  rootCtx = isBrowser ? window : global;
  if (typeof module === 'object' && typeof module.exports === 'object') {
    return module.exports = factory(rootCtx);
  } else if (typeof define === 'function' && define.amd) {
    return define(function() {
      return factory(rootCtx);
    });
  } else {
    return rootCtx.rawAsap = factory(rootCtx);
  }
})(function(global) {

  /*
  Asap library port with ability to provide context object in which callback should be run to avoid creation of closures.
   */
  var BrowserMutationObserver, capacity, flush, flushing, hasSetImmediate, index, makeRequestCallFromMutationObserver, makeRequestCallFromTimer, queue, requestFlush;
  queue = [];
  flushing = false;
  requestFlush = void 0;
  index = 0;
  capacity = 1024;
  flush = function() {

    /*
    The flush function processes all tasks that have been scheduled with
    `rawAsap` unless and until one of those tasks throws an exception.
    If a task throws an exception, `flush` ensures that its state will remain
    consistent and will resume where it left off when called again.
    However, `flush` does not make any arrangements to be called again if an
    exception is thrown.
     */
    var currentIndex, len, scan;
    while (index < queue.length) {
      currentIndex = index;
      index = index + 2;
      queue[currentIndex].call(queue[currentIndex + 1]);
      if (index > capacity) {
        scan = 0;
        len = queue.length - index;
        while (scan < len) {
          queue[scan] = queue[scan + index];
          scan++;
        }
        queue.length -= index;
        index = 0;
      }
    }
    queue.length = 0;
    index = 0;
    return flushing = false;
  };
  makeRequestCallFromMutationObserver = function(callback) {

    /*
    To request a high priority event, we induce a mutation observer by toggling
    the text of a text node between "1" and "-1".
     */
    var node, observer, toggle;
    toggle = 1;
    observer = new BrowserMutationObserver(callback);
    node = document.createTextNode('');
    observer.observe(node, {
      characterData: true
    });
    return function() {
      toggle = -toggle;
      return node.data = toggle;
    };
  };
  makeRequestCallFromTimer = function(callback) {

    /*
    `setTimeout` does not call the passed callback if the delay is less than
    approximately 7 in web workers in Firefox 8 through 18, and sometimes not
    even then.
     */
    return function() {
      var handleTimer, intervalHandle, timeoutHandle;
      handleTimer = function() {
        clearTimeout(timeoutHandle);
        clearInterval(intervalHandle);
        return callback();
      };
      timeoutHandle = setTimeout(handleTimer, 0);
      return intervalHandle = setInterval(handleTimer, 50);
    };
  };
  if (typeof window !== 'undefined' && window.document) {
    BrowserMutationObserver = window.MutationObserver || window.WebKitMutationObserver;
    if (typeof BrowserMutationObserver === 'function') {
      requestFlush = makeRequestCallFromMutationObserver(flush);
    } else {
      requestFlush = makeRequestCallFromTimer(flush);
    }
  } else {
    hasSetImmediate = typeof setImmediate === 'function';
    requestFlush = function() {
      var domain, parentDomain;
      parentDomain = process.domain;
      if (parentDomain) {
        if (!domain) {
          domain = require('domain');
        }
        domain.active = process.domain = null;
      }
      if (flushing && hasSetImmediate) {
        setImmediate(flush);
      } else {
        process.nextTick(flush);
      }
      if (parentDomain) {
        return domain.active = process.domain = parentDomain;
      }
    };
  }
  return function(ctx, task) {

    /*
    asapInContext function.
    @param {Object} ctx - context object which will be `this` for the callback
    @param {Function} task - callback function that is added to the high-priority queue
     */
    if (!queue.length) {
      requestFlush();
      flushing = true;
    }
    queue[queue.length] = task;
    queue[queue.length] = ctx;
  };
});
