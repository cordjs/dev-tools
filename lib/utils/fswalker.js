// Generated by CoffeeScript 1.7.1
var EventEmitter, FsWalker, Future, fs, path, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

fs = require('fs');

path = require('path');

EventEmitter = require('events').EventEmitter;

_ = require('underscore');

Future = require('./Future');

FsWalker = (function(_super) {
  __extends(FsWalker, _super);


  /*
  Simple implementation of recursive file-system walker using async Futures.
  The class emits events with the same semantics as npm walk library.
  Additionally it has filter-function support to avoid walking throught unnecessary directories.
   */

  FsWalker.prototype._filterFn = null;

  FsWalker.prototype._itemQueue = null;

  FsWalker.prototype._active = false;

  FsWalker.prototype._scanFinished = false;

  function FsWalker(dir, options) {
    this._next = __bind(this._next, this);
    if (options != null) {
      this._filterFn = _.isFunction(options.filter) ? options.filter : function() {
        return true;
      };
    }
    this._itemQueue = [];
    this._walk(dir).failAloud().done((function(_this) {
      return function() {
        _this._scanFinished = true;
        if (!_this._active) {
          return _this.emit('end');
        }
      };
    })(this));
  }

  FsWalker.prototype._walk = function(root, name) {

    /*
    @param String root absolute path to the directory containing item to be scanned
    @param String name local name of the file or directory to be scanned
    @return Future completed when the given FS item is scanned and added to the event-emitter queue
     */
    var target;
    target = name ? path.join(root, name) : root;
    return Future.call(fs.lstat, target).flatMap((function(_this) {
      return function(stat) {
        stat.name = name;
        if (stat.isDirectory()) {
          return Future.call(fs.readdir, target).flatMap(function(items) {
            var futures, item;
            futures = (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = items.length; _i < _len; _i++) {
                item = items[_i];
                if (this._filterFn(target, item)) {
                  _results.push(this._walk(target, item));
                }
              }
              return _results;
            }).call(_this);
            if (name) {
              _this._add('directory', root, stat);
            }
            return Future.sequence(futures);
          });
        } else if (stat.isSymbolicLink()) {
          _this._add('symbolicLink', root, stat);
          return Future.resolved();
        } else if (stat.isFile()) {
          _this._add('file', root, stat);
          return Future.resolved();
        } else {
          return Future.resolved();
        }
      };
    })(this)).flatMapFail(function(err) {
      if (err.code === 'ENOENT') {
        return Future.resolved();
      } else {
        return Future.rejected(err);
      }
    });
  };

  FsWalker.prototype._add = function(type, root, stat) {
    this._itemQueue.push([type, root, stat]);
    if (!this._active) {
      return this._next();
    }
  };

  FsWalker.prototype._next = function() {

    /*
    Chained event-emitter. Passed to every event callback and must be called by the handler in order to continue
     emitting.
     */
    var item, root, stat, type, _results;
    _results = [];
    while (true) {
      item = this._itemQueue.shift();
      if (item != null) {
        type = item[0], root = item[1], stat = item[2];
        if (EventEmitter.listenerCount(this, type)) {
          this._active = true;
          this.emit(type, root, stat, this._next);
        } else {
          continue;
        }
      } else {
        this._active = false;
        if (this._scanFinished) {
          this.emit('end');
        }
      }
      break;
    }
    return _results;
  };

  return FsWalker;

})(EventEmitter);

module.exports = function(dir, options) {
  return new FsWalker(dir, options);
};
