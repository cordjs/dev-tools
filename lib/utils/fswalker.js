// Generated by CoffeeScript 1.9.1
var EventEmitter, FsWalker, Future, _, fs, path,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

fs = require('fs');

path = require('path');

EventEmitter = require('events').EventEmitter;

_ = require('underscore');

Future = require('./Future');

FsWalker = (function(superClass) {
  extend(FsWalker, superClass);


  /*
  Simple implementation of recursive file-system walker using async Futures.
  The class emits events with the same semantics as npm walk library.
  Additionally it has filter-function support to avoid walking throught unnecessary directories.
   */

  FsWalker.prototype._filterFn = null;

  FsWalker.prototype._itemQueue = null;

  FsWalker.prototype._active = false;

  FsWalker.prototype._scanFinished = false;

  function FsWalker(dir, options) {
    this._next = bind(this._next, this);
    if (options != null) {
      this._filterFn = _.isFunction(options.filter) ? options.filter : function() {
        return true;
      };
    }
    this._itemQueue = [];
    this._walk(dir).failAloud().done((function(_this) {
      return function() {
        _this._scanFinished = true;
        if (!_this._active) {
          return _this.emit('end');
        }
      };
    })(this));
  }

  FsWalker.prototype._walk = function(root, name) {

    /*
    @param String root absolute path to the directory containing item to be scanned
    @param String name local name of the file or directory to be scanned
    @return Future completed when the given FS item is scanned and added to the event-emitter queue
     */
    var target;
    target = name ? path.join(root, name) : root;
    return Future.call(fs.lstat, target).then((function(_this) {
      return function(stat) {
        stat.name = name;
        if (stat.isDirectory()) {
          return Future.call(fs.readdir, target).then(function(items) {
            var futures, item;
            futures = (function() {
              var i, len, results;
              results = [];
              for (i = 0, len = items.length; i < len; i++) {
                item = items[i];
                if (this._filterFn(target, item)) {
                  results.push(this._walk(target, item));
                }
              }
              return results;
            }).call(_this);
            if (name) {
              _this._add('directory', root, stat);
            }
            return Future.all(futures);
          }).then(_.noop);
        } else if (stat.isSymbolicLink()) {
          return _this._add('symbolicLink', root, stat);
        } else if (stat.isFile()) {
          return _this._add('file', root, stat);
        } else {

        }
      };
    })(this)).catchIf(function(err) {
      return err.code === 'ENOENT';
    });
  };

  FsWalker.prototype._add = function(type, root, stat) {
    this._itemQueue.push([type, root, stat]);
    if (!this._active) {
      this._next();
    }
  };

  FsWalker.prototype._next = function() {

    /*
    Chained event-emitter. Passed to every event callback and must be called by the handler in order to continue
     emitting.
     */
    var item, results, root, stat, type;
    results = [];
    while (true) {
      item = this._itemQueue.shift();
      if (item != null) {
        type = item[0], root = item[1], stat = item[2];
        if (EventEmitter.listenerCount(this, type)) {
          this._active = true;
          this.emit(type, root.replace(/\\/g, '/'), stat, this._next);
        } else {
          continue;
        }
      } else {
        this._active = false;
        if (this._scanFinished) {
          this.emit('end');
        }
      }
      break;
    }
    return results;
  };

  return FsWalker;

})(EventEmitter);

module.exports = function(dir, options) {
  return new FsWalker(dir, options);
};
