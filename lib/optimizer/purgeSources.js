// Generated by CoffeeScript 1.9.1
var Future, fs, path, purgeCssFiles, purgeEmptyFolders, purgeJsFiles, removeTests, requirejsConfig, rmrf;

fs = require('fs');

path = require('path');

Future = require('../utils/Future');

rmrf = require('../utils/rmrf');

requirejsConfig = require('./requirejsConfig');

module.exports = function(targetDir) {

  /*
  Removes source js and css files that are included into the optimized groups.
  Also removes compiled tests and empty folders.
  This procedure can be used to prepare browser-only build (e.g. phonegap).
  @param {String} targetDir - target directory of the optimized build
  @return {Future<undefined>}
   */
  var start;
  console.log("Removing source files...");
  start = process.hrtime();
  return Future.require(targetDir + "/conf/optimizer-group-cache-generated").then(function(groupMap) {
    return Future.all([purgeCssFiles(targetDir, groupMap.css), purgeJsFiles(targetDir, groupMap.js), removeTests(targetDir)]);
  }).then(function() {
    console.log("Removing empty folders...");
    return purgeEmptyFolders(targetDir);
  }).then(function() {
    var diff;
    diff = process.hrtime(start);
    return console.log("Purge sources complete in " + ((diff[0] * 1e9 + diff[1]) / 1e6) + " ms");
  }).failAloud('optimizer::purgeSources');
};

purgeCssFiles = function(targetDir, groupMap) {
  var files, relative, removePromises;
  files = Object.keys(groupMap);
  removePromises = (function() {
    var i, len, results1;
    results1 = [];
    for (i = 0, len = files.length; i < len; i++) {
      relative = files[i];
      results1.push(Future.call(fs.unlink, targetDir + "/public" + relative));
    }
    return results1;
  })();
  return Future.all(removePromises).then(function() {});
};

purgeJsFiles = function(targetDir, groupMap) {
  return requirejsConfig.collect(targetDir).then(function(requireConfig) {
    var files, paths, relative, removePromises;
    paths = requireConfig.paths;
    files = Object.keys(groupMap);
    removePromises = (function() {
      var i, len, results1;
      results1 = [];
      for (i = 0, len = files.length; i < len; i++) {
        relative = files[i];
        if (paths[relative]) {
          relative = paths[relative];
        }
        results1.push(Future.call(fs.unlink, targetDir + "/public/" + relative + ".js"));
      }
      return results1;
    })();
    return Future.all(removePromises);
  }).then(function() {});
};

removeTests = function(targetDir) {
  return rmrf(targetDir + "/test");
};

purgeEmptyFolders = function(target) {

  /*
  Recursively deep scans the given absolute path and removes all empty directories.
  @param {String} target
  @return {Future<Boolean>} true if the path was empty directory, false otherwise
   */
  if (path.resolve(target) === path.normalize(target) && target.trim().length > 5) {
    return Future.call(fs.lstat, target).then(function(stat) {
      if (stat.isDirectory()) {
        return Future.call(fs.readdir, target).then(function(items) {
          var futures, item;
          futures = (function() {
            var i, len, results1;
            results1 = [];
            for (i = 0, len = items.length; i < len; i++) {
              item = items[i];
              results1.push(purgeEmptyFolders(path.join(target, item)));
            }
            return results1;
          })();
          return Future.all(futures);
        }).then(function(results) {
          if (results.indexOf(false) === -1) {
            return Future.call(fs.rmdir, target).then(function() {
              return true;
            });
          } else {
            return false;
          }
        });
      } else {
        return false;
      }
    })["catch"](function(err) {
      if (err.code === 'ENOENT') {
        return true;
      } else {
        throw err;
      }
    });
  } else {
    return Future.rejected(new Error("Only absolute and not short top-level paths are supported, '" + target + "' given!"));
  }
};
