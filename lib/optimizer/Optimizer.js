// Generated by CoffeeScript 1.6.3
var ByWidgetGroupDetector, CorrelationGroupDetector, Future, GroupRepo, HeuristicGroupDetector, Optimizer, UglifyJS, browserInitGenerator, coffeeUtilCode, fs, mkdirp, requirejsConfig, sha1, _;

fs = require('fs');

_ = require('underscore');

mkdirp = require('mkdirp');

UglifyJS = require('uglify-js');

Future = require('../utils/Future');

sha1 = require('../utils/sha1');

ByWidgetGroupDetector = require('./ByWidgetGroupDetector');

browserInitGenerator = require('./browserInitGenerator');

CorrelationGroupDetector = require('./CorrelationGroupDetector');

GroupRepo = require('./GroupRepo');

HeuristicGroupDetector = require('./HeuristicGroupDetector');

requirejsConfig = require('./requirejsConfig');

coffeeUtilCode = ['__hasProp = {}.hasOwnProperty', '__extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }', '__bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }', '__slice = [].slice', '__indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }'];

Optimizer = (function() {
  /*
  Build optimizer.
  * grouping modules into single files
  * minifying, gzipping
  * and so on
  */

  Optimizer.prototype._zDir = null;

  Optimizer.prototype._requireConfig = null;

  function Optimizer(params) {
    this.params = params;
    this._zDir = "" + this.params.targetDir + "/public/assets/z";
  }

  Optimizer.prototype.run = function() {
    var start, statFile,
      _this = this;
    start = process.hrtime();
    statFile = 'require-stat.json';
    return fs.readFile(statFile, function(err, data) {
      var groupMap, stat;
      _this._requireConfig = requirejsConfig.collect(_this.params.targetDir);
      stat = err ? {} : JSON.parse(data);
      console.log("Calculating group optimization...");
      groupMap = _this._generateOptimizationMap(stat);
      return _this._generateOptimizedFiles(groupMap).done(function() {
        var diff;
        diff = process.hrtime(start);
        return console.log("Optimization complete in " + ((diff[0] * 1e9 + diff[1]) / 1e6) + " ms");
      });
    });
  };

  Optimizer.prototype._generateOptimizationMap = function(stat) {
    /*
    Analizes collected requirejs stats and tryes to group modules together in optimized way.
    @param Map[String -> Array[String]] stat collected statistics of required files per page
    @return Map[String -> Array[String]]
    */

    var corrDetector, group, groupId, groupRepo, groups, heuristicDetector, iterations, page, resultMap, widgetDetector, _i, _len;
    iterations = 1;
    groupRepo = new GroupRepo;
    widgetDetector = new ByWidgetGroupDetector(groupRepo);
    stat = widgetDetector.process(stat);
    while (iterations--) {
      corrDetector = new CorrelationGroupDetector(groupRepo);
      stat = corrDetector.process(stat);
      heuristicDetector = new HeuristicGroupDetector(groupRepo);
      stat = heuristicDetector.process(stat);
    }
    resultMap = {};
    for (page in stat) {
      groups = stat[page];
      for (_i = 0, _len = groups.length; _i < _len; _i++) {
        groupId = groups[_i];
        group = groupRepo.getGroup(groupId);
        if (group) {
          resultMap[groupId] = _.uniq(group.getModules());
        }
      }
    }
    return resultMap;
  };

  Optimizer.prototype._generateOptimizedFiles = function(groupMap) {
    /*
    Generates and saves optimized module group and configuration files
    @param Map[String -> Array[String]] groupMap optimized group map
    @return Future
    */

    var _this = this;
    return this._requireConfig.flatMap(function(requireConf) {
      console.log("Merging group files...");
      return _this._mergeGroups(groupMap, requireConf);
    }).flatMap(function(mergedMap) {
      console.log("Generating browser-init script...");
      return browserInitGenerator.generate(mergedMap, _this.params);
    }).flatMap(function(browserInitScriptString) {
      var fileName;
      fileName = sha1(browserInitScriptString);
      return Future.call(fs.writeFile, "" + _this._zDir + "/" + fileName + ".js", browserInitScriptString).zip(Future.call(fs.writeFile, "" + _this._zDir + "/browser-init.id", fileName));
    });
  };

  Optimizer.prototype._mergeGroups = function(groupMap, requireConf) {
    /*
    Launches merge for all optimized groups.
    Returns converted group map with group names replaced with generated merged file names
    @param Map[String -> Array[String]] groupMap source group map
    @param Object requireConf requirejs configuration object
    @return Future[Map[String -> Array[String]]
    */

    var groupId, modules, result, resultMap, _fn,
      _this = this;
    result = new Future(1);
    resultMap = {};
    _fn = function(modules) {
      result.fork();
      return _this._mergeGroup(_this._reorderShimModules(modules, requireConf.shim), requireConf).done(function(fileName) {
        resultMap[fileName] = modules;
        return result.resolve();
      });
    };
    for (groupId in groupMap) {
      modules = groupMap[groupId];
      _fn(modules);
    }
    return result.resolve().map(function() {
      return resultMap;
    });
  };

  Optimizer.prototype._mergeGroup = function(modules, requireConf) {
    /*
    Merges the given modules list into one big optimized file. Order of the modules is preserved.
    Returns future with optimized file name.
    @param Array[String] modules list of group modules
    @param Object requireConf requirejs configuration object
    @return Future[String]
    */

    var contentArr, csUtilHit, futures, j, module,
      _this = this;
    contentArr = [];
    csUtilHit = {};
    futures = (function() {
      var _i, _len, _results,
        _this = this;
      _results = [];
      for (j = _i = 0, _len = modules.length; _i < _len; j = ++_i) {
        module = modules[j];
        _results.push((function(module, j) {
          var moduleFile;
          moduleFile = requireConf.paths[module] ? "" + _this.params.targetDir + "/public/" + requireConf.paths[module] + ".js" : "" + _this.params.targetDir + "/public/" + module + ".js";
          return Future.call(fs.readFile, moduleFile, 'utf8').map(function(origJs) {
            var code, definePresent, deps, i, js, shim, _j, _len1;
            js = origJs.replace('define([', "define('" + module + "',[").replace('define( [', "define('" + module + "',[").replace('define(function()', "define('" + module + "',function()");
            definePresent = js !== origJs || js.indexOf('define.amd') > -1;
            for (i = _j = 0, _len1 = coffeeUtilCode.length; _j < _len1; i = ++_j) {
              code = coffeeUtilCode[i];
              if (js.indexOf(code) > -1) {
                js = js.replace(code + ",\n  ", '');
                js = js.replace(code, '');
                csUtilHit[i] = true;
              }
            }
            js = js.replace("var ;\n", '');
            if ((shim = requireConf.shim[module]) && (shim.exports != null) && _.isString(shim.exports)) {
              deps = _.isArray(shim.deps) && shim.deps.length > 0 ? "['" + (shim.deps.join("','")) + "'], " : '';
              js += "\ndefine('" + module + "', " + deps + (_this._generateShimExportsFn(shim)) + ");\n";
            } else if (!definePresent) {
              js += "\ndefine('" + module + "', function(){});\n";
            }
            contentArr[j] = js;
            return true;
          }).mapFail(function() {
            return false;
          });
        })(module, j));
      }
      return _results;
    }).call(this);
    return Future.call(mkdirp, this._zDir).zip(Future.sequence(futures)).flatMap(function() {
      var fileName, hit, i, mergedContent, resultCode;
      resultCode = '';
      hit = Object.keys(csUtilHit);
      if (hit.length > 0) {
        resultCode += 'var ' + ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = hit.length; _i < _len; _i++) {
            i = hit[_i];
            _results.push(coffeeUtilCode[i]);
          }
          return _results;
        })()).join(',\n  ') + ';\n\n';
      }
      mergedContent = resultCode + contentArr.join("\n\n");
      fileName = sha1(mergedContent);
      console.log("Saving " + fileName + "...");
      return Future.call(fs.writeFile, "" + _this._zDir + "/" + fileName + ".js", mergedContent).map(function() {
        return fileName;
      });
    }).failAloud();
  };

  Optimizer.prototype._generateShimExportsFn = function(shimConfig) {
    /*
    Generates special function code for shim-module definition. Stolen from the requirejs sources.
    @param Object shimConfig shim configuration for the module
    @return String
    */

    return '(function (global) {\n' +
    '    return function () {\n' +
    '        var ret, fn;\n' +
    (shimConfig.init ?
            ('       fn = ' + shimConfig.init.toString() + ';\n' +
            '        ret = fn.apply(global, arguments);\n') : '') +
    (shimConfig.exports ?
            '        return ret || global.' + shimConfig.exports + ';\n' :
            '        return ret;\n') +
    '    };\n' +
    '}(this))';
  };

  Optimizer.prototype._reorderShimModules = function(modules, requirejsShim) {
    /*
    Reorders the given list of modules according to their dependency tree from the shim configuration.
    Order of modules that are not present in shim configuration is leaved untouch. Shim modules are placed in the end.
    In the result array the module A which depends on module B comes after module B.
    @param Array[String] modules source module list
    @param Object requirejsShim shim configuration part of requirejs configuration config object
    @return Array[String]
    */

    var depInfo, depModule, depOrder, deps, i, info, max, module, orderInfo, orderUnresolved, resultModules, shimModules, unresolved, _i, _j, _k, _len, _len1, _name, _ref, _ref1;
    orderInfo = {};
    for (module in requirejsShim) {
      info = requirejsShim[module];
      if ((info.deps != null) && info.deps.length > 0) {
        orderInfo[module] = {};
        _ref = info.deps;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          depModule = _ref[_i];
          if (requirejsShim[depModule] != null) {
            orderInfo[module][depModule] = false;
          } else {
            orderInfo[depModule] = 0;
            orderInfo[module][depModule] = false;
          }
        }
      } else {
        orderInfo[module] = 0;
      }
    }
    while (true) {
      orderUnresolved = false;
      for (module in orderInfo) {
        deps = orderInfo[module];
        if (_.isObject(deps)) {
          unresolved = false;
          for (depModule in deps) {
            depInfo = deps[depModule];
            if (depInfo === false) {
              if (!_.isObject(orderInfo[depModule])) {
                deps[depModule] = orderInfo[depModule] + 1;
              } else {
                unresolved = true;
              }
            }
          }
          if (!unresolved) {
            max = 0;
            for (depModule in deps) {
              depOrder = deps[depModule];
              if (depOrder > max) {
                max = depOrder;
              }
            }
            orderInfo[module] = max;
          } else {
            orderUnresolved = true;
          }
        }
      }
      if (!orderUnresolved) {
        break;
      }
    }
    shimModules = {};
    resultModules = [];
    for (_j = 0, _len1 = modules.length; _j < _len1; _j++) {
      module = modules[_j];
      if (orderInfo[module] != null) {
        if (shimModules[_name = orderInfo[module]] == null) {
          shimModules[_name] = [];
        }
        shimModules[orderInfo[module]].push(module);
      } else {
        resultModules.push(module);
      }
    }
    if (Object.keys(shimModules).length > 0) {
      for (i = _k = 0, _ref1 = _.max(Object.keys(shimModules)); 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        if (shimModules[i] != null) {
          resultModules = resultModules.concat(shimModules[i]);
        }
      }
    }
    return resultModules;
  };

  return Optimizer;

})();

module.exports = Optimizer;
