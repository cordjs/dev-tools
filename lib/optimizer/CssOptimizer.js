// Generated by CoffeeScript 1.7.1
var CleanCss, CorrelationGroupDetector, CssOptimizer, Future, GroupRepo, HeuristicGroupDetector, cleanCss, fs, path, relativeReplaceRe, sha1, _;

fs = require('fs');

path = require('path');

_ = require('underscore');

CleanCss = require('clean-css');

Future = require('../utils/Future');

sha1 = require('../utils/sha1');

CorrelationGroupDetector = require('./CorrelationGroupDetector');

GroupRepo = require('./GroupRepo');

HeuristicGroupDetector = require('./HeuristicGroupDetector');

cleanCss = new CleanCss;

relativeReplaceRe = /url\(['"]((?!data:|\/|http:\/\/)[^'"]+)['"]\)/gi;

CssOptimizer = (function() {

  /*
  CSS files optimizer.
  * grouping files into single files
  * minifying, gzipping
  * and so on
   */
  CssOptimizer.prototype._zDir = null;

  CssOptimizer.prototype._globalOrder = null;

  function CssOptimizer(params, zDirFuture) {
    this.params = params;
    this.zDirFuture = zDirFuture;
    this._zDir = "" + this.params.targetDir + "/public/assets/z";
  }

  CssOptimizer.prototype.run = function() {
    var cssStatFile;
    cssStatFile = 'css-stat.json';
    return Future.call(fs.readFile, cssStatFile).flatMap((function(_this) {
      return function(data) {
        var groupMap, stat;
        stat = JSON.parse(data);
        _this._calculateGlobalOrder(stat);
        console.log("Calculating css group optimization...");
        groupMap = _this._generateOptimizationMap(stat);
        return _this._generateOptimizedFiles(groupMap);
      };
    })(this)).mapFail(function(e) {
      console.warn("CSS group optimization failed! Reason: " + e + ". Skipping...");
      return {};
    });
  };

  CssOptimizer.prototype._generateOptimizationMap = function(stat) {
    var corrDetector, group, groupId, groupRepo, groups, heuristicDetector, iterations, page, resultMap, _i, _len;
    iterations = 1;
    groupRepo = new GroupRepo;
    while (iterations--) {
      console.log("100% correlation CSS group detection...");
      corrDetector = new CorrelationGroupDetector(groupRepo);
      stat = corrDetector.process(stat);
      console.log("Heuristic CSS group detection...");
      heuristicDetector = new HeuristicGroupDetector(groupRepo);
      stat = heuristicDetector.process(stat);
    }
    resultMap = {};
    for (page in stat) {
      groups = stat[page];
      for (_i = 0, _len = groups.length; _i < _len; _i++) {
        groupId = groups[_i];
        group = groupRepo.getGroup(groupId);
        if (group) {
          resultMap[groupId] = _.uniq(group.getModules());
        }
      }
    }
    return resultMap;
  };

  CssOptimizer.prototype._generateOptimizedFiles = function(groupMap) {

    /*
    Generates and saves optimized module group and configuration files
    @param Map[String -> Array[String]] groupMap optimized group map
    @return Future
     */
    console.log("Merging CSS group files...");
    return this._mergeGroups(groupMap).flatMap((function(_this) {
      return function(mergedGroupMap) {
        var css, cssToGroup, fileName, groupId, urls, _i, _len;
        cssToGroup = {};
        for (groupId in mergedGroupMap) {
          urls = mergedGroupMap[groupId];
          for (_i = 0, _len = urls.length; _i < _len; _i++) {
            css = urls[_i];
            cssToGroup[css] = groupId;
          }
        }
        fileName = "" + _this.params.targetDir + "/conf/css-to-group-generated.js";
        return Future.call(fs.writeFile, fileName, "define(function(){ return " + (JSON.stringify(cssToGroup, null, 2)) + "; });").map(function() {
          return mergedGroupMap;
        });
      };
    })(this));
  };

  CssOptimizer.prototype._mergeGroups = function(groupMap) {

    /*
    Launches merge for all optimized groups.
    Returns converted group map with group names replaced with generated merged file names
    @param Map[String -> Array[String]] groupMap source group map
    @param Object requireConf requirejs configuration object
    @return Future[Map[String -> Array[String]]
     */
    var cssFiles, groupId, result, resultMap, _fn;
    result = new Future(1);
    resultMap = {};
    _fn = (function(_this) {
      return function(cssFiles) {
        result.fork();
        return _this._mergeGroup(_this._reorderGroupFiles(cssFiles)).done(function(fileName, existingFiles) {
          resultMap[fileName] = existingFiles;
          return result.resolve();
        });
      };
    })(this);
    for (groupId in groupMap) {
      cssFiles = groupMap[groupId];
      _fn(cssFiles);
    }
    return result.resolve().map(function() {
      return resultMap;
    });
  };

  CssOptimizer.prototype._mergeGroup = function(cssFiles) {

    /*
    Merges the given modules list into one big optimized file. Order of the modules is preserved.
    Returns future with optimized file name.
    @param Array[String] modules list of group modules
    @param Object requireConf requirejs configuration object
    @return Future[String]
     */
    var contentArr, existingFiles, file, futures, j;
    existingFiles = [];
    contentArr = [];
    futures = (function() {
      var _i, _len, _results;
      _results = [];
      for (j = _i = 0, _len = cssFiles.length; _i < _len; j = ++_i) {
        file = cssFiles[j];
        _results.push((function(_this) {
          return function(file, j) {
            var filePath;
            filePath = "" + _this.params.targetDir + "/public" + file;
            return Future.call(fs.readFile, filePath, 'utf8').map(function(origCss) {
              var css, fileBaseUrl;
              fileBaseUrl = path.dirname(file);
              css = origCss.replace(relativeReplaceRe, "url(\"" + fileBaseUrl + "/$1\")");
              css = "/* " + file + " */\n\n" + css + "\n";
              contentArr[j] = css;
              existingFiles.push(file);
              return true;
            }).mapFail(function() {
              return false;
            });
          };
        })(this)(file, j));
      }
      return _results;
    }).call(this);
    return Future.sequence(futures).zip(this.zDirFuture).flatMap((function(_this) {
      return function() {
        var fileName, mergedContent;
        mergedContent = contentArr.join("\n\n");
        if (_this.params.cssMinify) {
          mergedContent = cleanCss.minify(mergedContent);
        }
        fileName = sha1(mergedContent);
        console.log("Saving " + fileName + ".css ...");
        return Future.call(fs.writeFile, "" + _this._zDir + "/" + fileName + ".css", mergedContent).map(function() {
          return [fileName, existingFiles];
        });
      };
    })(this)).failAloud('CssOptimizer::_mergeGroup');
  };

  CssOptimizer.prototype._reorderGroupFiles = function(cssFiles) {

    /*
    Returns ordered css-files according to the pre-computed global order list
    @param Array[String] cssFiles
    @return Array[String]
     */
    return _.sortBy(cssFiles, (function(_this) {
      return function(f) {
        return _this._globalOrder.indexOf(f);
      };
    })(this));
  };

  CssOptimizer.prototype._calculateGlobalOrder = function(stat) {

    /*
    Calculates and saves global order of the css-files based on stats collected from the browser loading order.
    In some cases it's not possible to construct strict order of all files. In those cases approximation is assumed.
    @param Map[String, Array[String]] stat
     */
    var file, files, i, k, keys, p, prepends, preps, preps1, prevLength, ready, result, s, _i, _j, _len, _len1;
    prepends = {};
    for (p in stat) {
      files = stat[p];
      for (i = _i = 0, _len = files.length; _i < _len; i = ++_i) {
        file = files[i];
        if (prepends[file] == null) {
          prepends[file] = [];
        }
        prepends[file] = prepends[file].concat(files.slice(0, i));
      }
    }
    for (file in prepends) {
      preps = prepends[file];
      preps = _.uniq(preps);
      prepends[file] = {
        files: preps,
        size: preps.length
      };
    }
    result = [];
    prevLength = Object.keys(prepends).length + 1;
    while ((keys = Object.keys(prepends)) && keys.length > 0 && keys.length < prevLength) {
      prevLength = keys.length;
      ready = [];
      s = 0;
      while (ready.length === 0) {
        ready = _.filter(keys, function(k) {
          return prepends[k].size === s;
        });
        s++;
      }
      if (s > 1) {
        ready = [ready[0]];
      }
      result = result.concat(ready);
      for (_j = 0, _len1 = ready.length; _j < _len1; _j++) {
        k = ready[_j];
        delete prepends[k];
      }
      for (file in prepends) {
        preps = prepends[file];
        preps1 = _.difference(preps.files, ready);
        prepends[file] = {
          files: preps1,
          size: preps1.length
        };
      }
    }
    return this._globalOrder = result;
  };

  return CssOptimizer;

})();

module.exports = CssOptimizer;
