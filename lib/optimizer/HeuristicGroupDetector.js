// Generated by CoffeeScript 1.9.1
var HeuristicGroupDetector, _, generateGroupId, getCountMap, invertStatMap, sha1;

_ = require('underscore');

sha1 = require('../utils/sha1');

HeuristicGroupDetector = (function() {
  function HeuristicGroupDetector(groupRepo) {
    this.groupRepo = groupRepo;
  }

  HeuristicGroupDetector.prototype.process = function(stat) {

    /*
    Heuristic algorithm is based on iteratively finding of best pairs of modules using sorted by usage frequency
     module list. Loop is interrupted when the best intersection rate is less then 0.2.
    
    @param {Object<String, Array<String>>} stat
    @return {Object<String, Array<String>>} modified stat with modules replaced by their respective groups.
     */
    var bestGroup, countMap, curStat, i, j, lengthBefore, m1, m2, maxRank, moduleList, modules, optimizedStat, page, pages1, pages2, pagesByModule, pair, rank, ref, sortedModuleList;
    curStat = stat;
    while (true) {
      pagesByModule = invertStatMap(curStat);
      countMap = getCountMap(pagesByModule);
      sortedModuleList = Object.keys(countMap);
      sortedModuleList = _.sortBy(sortedModuleList, (function(_this) {
        return function(m) {
          return countMap[m];
        };
      })(this));
      if (sortedModuleList.length < 2) {
        break;
      }
      maxRank = 0;
      pair = void 0;
      for (i = j = 0, ref = sortedModuleList.length - 2; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        m1 = sortedModuleList[i];
        m2 = sortedModuleList[i + 1];
        pages1 = pagesByModule[m1];
        pages2 = pagesByModule[m2];
        rank = _.intersection(pages1, pages2).length / pages2.length;
        if (rank > maxRank) {
          maxRank = rank;
          pair = [m1, m2];
        }
      }
      if (maxRank < 0.2) {
        break;
      }
      bestGroup = this.groupRepo.createGroup(generateGroupId(pair), pair);
      optimizedStat = {};
      for (page in curStat) {
        moduleList = curStat[page];
        modules = _.clone(moduleList);
        lengthBefore = modules.length;
        modules = _.difference(modules, bestGroup.getItems());
        if (lengthBefore > modules.length && bestGroup.getModules().length < 20) {
          modules.push(bestGroup.id);
        }
        optimizedStat[page] = modules;
      }
      curStat = optimizedStat;
    }
    return curStat;
  };

  return HeuristicGroupDetector;

})();

generateGroupId = function(items) {
  var itemsStr;
  itemsStr = items.sort().join();
  return 'group-heuristic-' + sha1(itemsStr) + '-' + items.length + '-' + itemsStr.substr(-12);
};

invertStatMap = function(stat) {

  /*
  Inverts stat map from `pageName -> Array<moduleName>` to `moduleName -> Array<pageName>`
  @param {Object<String, Array<String>>} stat
  @return {Object<String, Array<String>>}
   */
  var j, len, module, moduleList, page, result;
  result = {};
  for (page in stat) {
    moduleList = stat[page];
    for (j = 0, len = moduleList.length; j < len; j++) {
      module = moduleList[j];
      if (module.indexOf('/bundles/cord/core/init/browser-init.js') === -1) {
        if (result[module] == null) {
          result[module] = [];
        }
        result[module].push(page);
      }
    }
  }
  return result;
};

getCountMap = function(pagesByModule) {
  var module, pages, result;
  result = {};
  for (module in pagesByModule) {
    pages = pagesByModule[module];
    result[module] = pages.length;
  }
  return result;
};

module.exports = HeuristicGroupDetector;
