// Generated by CoffeeScript 1.9.1
var HeuristicGroupDetector, _, sha1;

_ = require('underscore');

sha1 = require('../utils/sha1');

HeuristicGroupDetector = (function() {
  HeuristicGroupDetector.prototype._countMap = null;

  HeuristicGroupDetector.prototype._curStat = null;

  HeuristicGroupDetector.prototype._maxGroupScore = 0;

  HeuristicGroupDetector.prototype._thresholdTime = 0;

  function HeuristicGroupDetector(groupRepo) {
    this.groupRepo = groupRepo;
  }

  HeuristicGroupDetector.prototype.process = function(stat) {
    var group, j, k, len, len1, lengthBefore, module, moduleList, moduleMap, modules, optimizedStat, page, pages, ref, ref1, remaining, resultGroups;
    this._countMap = {};
    ref = this._mapStat(stat);
    for (module in ref) {
      pages = ref[module];
      this._countMap[module] = pages.length;
    }
    this._curStat = {};
    for (page in stat) {
      moduleList = stat[page];
      this._curStat[page] = {};
      for (j = 0, len = moduleList.length; j < len; j++) {
        module = moduleList[j];
        this._curStat[page][module] = true;
      }
    }
    remaining = Object.keys(this._countMap);
    remaining = _.sortBy(remaining, (function(_this) {
      return function(m) {
        return _this._countMap[m];
      };
    })(this)).reverse();
    resultGroups = [];
    while (true) {
      group = this._findBestGroup(remaining);
      if (group !== false) {
        remaining = _.difference(remaining, group.getItems());
        remaining = (_.sortBy(remaining, (function(_this) {
          return function(m) {
            return _this._countMap[m];
          };
        })(this))).reverse();
        resultGroups.push(group);
        ref1 = this._curStat;
        for (page in ref1) {
          moduleMap = ref1[page];
          this._curStat[page] = _.omit(moduleMap, group.getItems());
          if (Object.keys(this._curStat[page]).length === 0) {
            delete this._curStat[page];
          }
        }
      } else {
        break;
      }
    }
    optimizedStat = {};
    for (page in stat) {
      moduleList = stat[page];
      modules = _.clone(moduleList);
      for (k = 0, len1 = resultGroups.length; k < len1; k++) {
        group = resultGroups[k];
        lengthBefore = modules.length;
        modules = _.difference(modules, group.getItems());
        if (lengthBefore > modules.length) {
          modules.push(group.id);
        }
      }
      optimizedStat[page] = modules;
    }
    return optimizedStat;
  };

  HeuristicGroupDetector.prototype._findBestGroup = function(moduleList) {
    var duration, groups, i, item, j, len;
    groups = [];
    this._maxGroupScore = 0;
    this._thresholdTime = (new Date).getTime() + 120000;
    for (i = j = 0, len = moduleList.length; j < len; i = ++j) {
      item = moduleList[i];
      groups = groups.concat(this._collectGroups([], moduleList, i, Object.keys(this._curStat), 0));
      if ((new Date).getTime() >= this._thresholdTime) {
        console.warn("Optimizer: interrupting calculation due to threshold time achieving!");
        break;
      }
    }
    duration = ((new Date).getTime() - (this._thresholdTime - 120000)) / 1000;
    if (duration > 5) {
      console.log("Found best group in", duration, "seconds");
    }
    if (groups.length > 0) {
      _.sortBy(groups, function(item) {
        return item[1];
      }).reverse();
      return this.groupRepo.createGroup(this._generateGroupId(groups[0][2]), groups[0][2]);
    } else {
      return false;
    }
  };

  HeuristicGroupDetector.prototype._collectGroups = function(prevGroup, list, startIndex, checkPages, level) {

    /*
    Recursive module group collector
    @param Array[String] prevGroup  accumulated on previous level existing group
    @param Array[String] list       source list of modules to process
    @param Int           startIndex which item of the list to start from (every recursive call must increase it)
    @param Array[String] checkPages short-list of pages to be used to check group existence (shortened by previous level)
    @param Int           level      nesting level for debugging
    @return Array[Array[(Int, Int, Array[String])]]
     */
    var avg, cnt, group, i, index, j, matchPages, ref, ref1, ref2, result, score, scoreArr, summ;
    result = [];
    if ((new Date).getTime() < this._thresholdTime) {
      for (i = j = ref = startIndex, ref1 = list.length; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {
        ref2 = this._groupExists(list[i], checkPages), cnt = ref2[0], matchPages = ref2[1];
        if (cnt > 0) {
          group = prevGroup.concat([list[i]]);
          scoreArr = _.map(group, (function(_this) {
            return function(m) {
              return [m, _this._countMap[m]];
            };
          })(this));
          summ = _.reduce(scoreArr, (function(res, item) {
            return res + item[1];
          }), 0);
          avg = summ / group.length;
          index = _.reduce(scoreArr, function(res, item) {
            var deviation;
            deviation = Math.abs(item[1] - avg);
            if (deviation < res[0]) {
              return [deviation, item[1]];
            } else {
              return res;
            }
          }, [2000000000, 0]);
          scoreArr = _.filter(scoreArr, function(item) {
            return Math.abs(item[1] - index[1]) <= 1;
          });
          score = cnt * scoreArr.length;
          if (score > this._maxGroupScore && group.length > 1) {
            result.push([cnt, score, group]);
            this._maxGroupScore = score;
            if ((new Date).getTime() > this._thresholdTime - 30000) {
              console.log("Optimizer: increasing threshold time...");
              this._thresholdTime += 30000;
            }
          }
          result = result.concat(this._collectGroups(group, list, i + 1, matchPages, level + 1));
        }
      }
    }
    return result;
  };

  HeuristicGroupDetector.prototype._groupExists = function(checkModule, checkPages) {

    /*
    Returns count of pages in which the given module is used.
    @param String checkModule module to check
    @param Array[String] checkPages list of pages to check
    @return Int
     */
    var count, j, len, matchPages, page;
    count = 0;
    matchPages = [];
    for (j = 0, len = checkPages.length; j < len; j++) {
      page = checkPages[j];
      if (this._curStat[page][checkModule]) {
        count++;
        matchPages.push(page);
      }
    }
    return [count, matchPages];
  };

  HeuristicGroupDetector.prototype._mapStat = function(stat) {
    var j, len, module, moduleList, page, result;
    result = {};
    for (page in stat) {
      moduleList = stat[page];
      for (j = 0, len = moduleList.length; j < len; j++) {
        module = moduleList[j];
        if (module.indexOf('/bundles/cord/core/init/browser-init.js') === -1) {
          if (result[module] == null) {
            result[module] = [];
          }
          result[module].push(page);
        }
      }
    }
    return result;
  };

  HeuristicGroupDetector.prototype._generateGroupId = function(items) {
    var itemsStr;
    itemsStr = items.sort().join();
    return 'group-heuristic-' + sha1(itemsStr) + '-' + items.length + '-' + itemsStr.substr(-12);
  };

  return HeuristicGroupDetector;

})();

module.exports = HeuristicGroupDetector;
