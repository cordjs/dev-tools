// Generated by CoffeeScript 1.9.1
var BuildSession, EventEmitter, Future, ProjectBuilder, ProjectWatcher, _, appConfig, buildManager, fileInfo, fs, fswalker, path, preparePath, requirejs, requirejsConfig, rmrf, sourceModified, walkerFilter,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

path = require('path');

fs = require('fs');

EventEmitter = require('events').EventEmitter;

_ = require('underscore');

preparePath = require('../utils/fsPreparePath');

requirejs = require(process.cwd() + '/node_modules/requirejs');

Future = require('../utils/Future');

rmrf = require('../utils/rmrf');

fswalker = require('../utils/fswalker');

appConfig = require('../appConfig');

requirejsConfig = require('./task/requirejs-config');

buildManager = require('./BuildManager');

BuildSession = require('./BuildSession');

fileInfo = require('./FileInfo');

ProjectWatcher = require('./ProjectWatcher');

walkerFilter = function(dir, name) {

  /*
  Filters hidden and temporary files from being handled by the builder.
  @param String dir dirname
  @param String name basename
  @return Boolean true if the file is OK for building, false if it should be skipped
   */
  var ext, res;
  res = name.charAt(0) === '.' ? false : (ext = path.extname(name), ext === '.orig' || ext.substr(-1) === '~' ? false : dir.indexOf('/.') === -1);
  return res;
};

ProjectBuilder = (function(superClass) {
  extend(ProjectBuilder, superClass);


  /*
  Builds the whole cordjs application project
   */

  ProjectBuilder.prototype._emitCompletePromise = null;

  function ProjectBuilder(params) {
    this.params = params;
    this.params.baseDir = preparePath(this.params.baseDir);
    fileInfo.setDirs(this.params.baseDir, this.params.targetDir);
    buildManager.generateSourceMap = this.params.map;
    if (this.params.watch) {
      this.setupWatcher();
    }
  }

  ProjectBuilder.prototype.build = function() {
    var appConfFile, appConfPromise, completePromise, corePromise, fullCompletePromise, nonWidgetFilesPromise, pathUtilsPromise, relativePos, scanBundle, scanCore, scanDir, scanRegularDir, start, widgetClassesPromise;
    console.log("Building project (full scan)...");
    start = process.hrtime();
    completePromise = new Future(1);
    corePromise = new Future(1);
    widgetClassesPromise = new Future(1);
    nonWidgetFilesPromise = new Future(1);
    relativePos = this.params.baseDir.length + 1;
    scanDir = (function(_this) {
      return function(dir, payloadCallback) {
        var walker;
        dir = preparePath(dir);
        completePromise.done(function() {
          return _this.watchDir(dir);
        });
        completePromise.fork();
        walker = fswalker(dir, {
          filter: walkerFilter
        });
        walker.on('file', function(root, stat, next) {
          var relativeDir;
          root = preparePath(root);
          relativeDir = root.substr(relativePos);
          payloadCallback(relativeDir + "/" + stat.name, stat);
          return setTimeout(next, 0);
        });
        walker.on('symbolicLink', function(root, stat, next) {
          var relativeDir;
          root = preparePath(root);
          relativeDir = root.substr(relativePos);
          payloadCallback(relativeDir + "/" + stat.name, stat);
          return next();
        });
        if (_this.params.watch) {
          walker.on('directory', function(root, stat, next) {
            root = preparePath(root);
            completePromise.done(function() {
              return _this.watchDir(root + "/" + stat.name);
            });
            return next();
          });
        }
        walker.on('end', function() {
          if (false) {
            console.log("walker for dir " + dir + " completed!");
          }
          return completePromise.resolve();
        });
        return walker;
      };
    })(this);
    scanRegularDir = (function(_this) {
      return function(dir) {
        return scanDir(dir, function(relativeName, stat) {
          var info;
          info = fileInfo.getFileInfo(relativeName);
          completePromise.fork();
          return sourceModified(relativeName, stat, _this.params.targetDir, info).then(function(modified) {
            if (modified) {
              completePromise.when(buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info));
            }
            completePromise.resolve();
          });
        });
      };
    })(this);
    scanCore = (function(_this) {
      return function() {
        return scanDir(_this.params.baseDir + "/public/bundles/cord/core", function(relativeName, stat) {
          var info;
          info = fileInfo.getFileInfo(relativeName, 'cord/core');
          completePromise.fork();
          return sourceModified(relativeName, stat, _this.params.targetDir, info).then(function(modified) {
            if (modified) {
              if (info.inWidgets) {
                if (info.isWidget) {
                  corePromise.then(function() {
                    return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                  }).link(completePromise).link(widgetClassesPromise);
                } else if (info.isWidgetTemplate) {
                  widgetClassesPromise.then(function() {
                    return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                  }).link(completePromise);
                } else if (info.isStylus) {
                  pathUtilsPromise.then(function() {
                    return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                  }).link(completePromise);
                } else {
                  buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info).link(completePromise);
                }
              } else if (!(info.fileName === 'pathUtils.coffee' && info.lastDirName === 'requirejs')) {
                buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info).link(corePromise).link(completePromise);
              }
            }
            completePromise.resolve();
          }).link(corePromise);
        }).on('end', function() {
          return corePromise.resolve();
        });
      };
    })(this);
    scanBundle = (function(_this) {
      return function(bundle) {
        widgetClassesPromise.fork();
        nonWidgetFilesPromise.fork();
        return scanDir(_this.params.baseDir + "/public/bundles/" + bundle, function(relativeName, stat) {
          var info;
          info = fileInfo.getFileInfo(relativeName, bundle);
          completePromise.fork();
          return sourceModified(relativeName, stat, _this.params.targetDir, info).then(function(modified) {
            if (modified) {
              if (info.isWidget) {
                corePromise.then(function() {
                  return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                }).link(completePromise).link(widgetClassesPromise);
              } else if (info.isWidgetTemplate) {
                Future.all([widgetClassesPromise, nonWidgetFilesPromise]).then(function() {
                  return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                }).link(completePromise);
              } else if (info.isCoffee && !info.inWidgets) {
                buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info).link(completePromise).link(nonWidgetFilesPromise);
              } else if (info.isStylus) {
                pathUtilsPromise.then(function() {
                  return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                }).link(completePromise);
              } else {
                buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info).link(completePromise);
              }
            }
            completePromise.resolve();
          });
        }).on('end', function() {
          widgetClassesPromise.resolve();
          return nonWidgetFilesPromise.resolve();
        });
      };
    })(this);
    appConfFile = "public/app/" + this.params.appConfigName;
    appConfPromise = buildManager.createTask(appConfFile + ".coffee", this.params.baseDir, this.params.targetDir, fileInfo.getFileInfo(appConfFile + ".coffee"));
    pathUtilsPromise = buildManager.createTask('public/bundles/cord/core/requirejs/pathUtils.coffee', this.params.baseDir, this.params.targetDir, fileInfo.getFileInfo('public/bundles/cord/core/requirejs/pathUtils.coffee', 'cord/core'));
    scanRegularDir(this.params.baseDir + '/public/vendor');
    scanRegularDir(this.params.baseDir + '/conf');
    scanRegularDir(this.params.baseDir + '/test');
    buildManager.createTask('server.coffee', this.params.baseDir, this.params.targetDir, fileInfo.getFileInfo('server.coffee')).link(completePromise);
    buildManager.createTask('optimizer-predefined-groups.coffee', this.params.baseDir, this.params.targetDir, fileInfo.getFileInfo('optimizer-predefined-groups.coffee'))["catch"](function() {}).link(completePromise);
    appConfPromise.then((function(_this) {
      return function() {
        scanCore();
        requirejs.config({
          baseUrl: _this.params.targetDir
        });
        return appConfig.getBundles(_this.params.targetDir);
      };
    })(this)).then(function(bundles) {
      var bundle, i, len;
      bundles = bundles.filter(function(n) {
        return n !== 'cord/core';
      });
      fileInfo.setBundles(bundles);
      for (i = 0, len = bundles.length; i < len; i++) {
        bundle = bundles[i];
        scanBundle(bundle);
      }
      widgetClassesPromise.resolve();
      nonWidgetFilesPromise.resolve();
      completePromise.resolve();
    }).failAloud();
    fullCompletePromise = this.params.indexPageWidget ? corePromise.then((function(_this) {
      return function() {
        return requirejsConfig(_this.params.targetDir);
      };
    })(this)).then(function() {
      return Future.all([Future.require('cord!requirejs/cord-w'), completePromise]);
    }).then((function(_this) {
      return function() {
        var info;
        info = {
          isIndexPage: true,
          configName: _this.params.config
        };
        return buildManager.createTask(_this.params.indexPageWidget, _this.params.baseDir, _this.params.targetDir, info);
      };
    })(this)) : completePromise;
    this._previousSessionPromise = fullCompletePromise["catch"](function() {
      return true;
    });
    return fullCompletePromise.then(function() {
      return 'completed';
    })["catch"](function(err) {
      console.error("Build error", err, err.stack);
      return 'failed';
    }).then((function(_this) {
      return function(verb) {
        var diff;
        diff = process.hrtime(start);
        console.log("Build " + verb + " in " + (parseFloat((diff[0] * 1e9 + diff[1]) / 1e9).toFixed(3)) + " s");
        if (verb === 'completed') {
          buildManager.stop();
          return _this.emit('complete');
        }
      };
    })(this)).failAloud('ProjectBuilder::build');
  };

  ProjectBuilder.prototype.setupWatcher = function() {
    this.watcher = new ProjectWatcher(this.params.baseDir);
    return this.watcher.on('change', (function(_this) {
      return function(changes) {
        var currentSessionPromise;
        if (_this._emitCompletePromise == null) {
          console.log('=====================');
          _this._emitCompletePromise = new Future;
          _this._emitCompletePromise.fork();
          _this._emitCompletePromise.done(function() {
            _this.emit('complete');
            return _this._emitCompletePromise = null;
          });
        } else {
          _this._emitCompletePromise.fork();
        }
        currentSessionPromise = _this._previousSessionPromise.then(function() {
          var removed, rmList;
          rmList = (function() {
            var i, len, ref, results;
            ref = _.sortBy(changes.removed, function(f) {
              return f.length;
            }).reverse();
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              removed = ref[i];
              console.log("removing " + removed + "...");
              results.push(rmrf(fileInfo.getTargetForSource(removed)).failAloud());
            }
            return results;
          })();
          return Future.all(rmList).then(function() {
            var buildSession, file, ref, scanCompletePromise, scanDir, sessionCompletePromise, stat;
            buildSession = new BuildSession(_this.params);
            sessionCompletePromise = Future.single();
            scanDir = function(dir) {
              var result, walker;
              result = Future.single();
              sessionCompletePromise.done(function() {
                return _this.watchDir(dir);
              });
              walker = fswalker(dir, {
                filter: walkerFilter
              });
              walker.on('file', function(root, stat, next) {
                buildSession.add(path.join(root, stat.name));
                return next();
              });
              walker.on('symbolicLink', function(root, stat, next) {
                buildSession.add(path.join(root, stat.name));
                return next();
              });
              walker.on('directory', function(root, stat, next) {
                sessionCompletePromise.done(function() {
                  return _this.watchDir(preparePath(root + "/" + stat.name));
                });
                return next();
              });
              walker.on('end', function() {
                if (false) {
                  console.log("walker for dir " + dir + " completed!");
                }
                return result.resolve();
              });
              return result;
            };
            scanCompletePromise = new Future;
            ref = changes.changed;
            for (file in ref) {
              stat = ref[file];
              if (stat.isFile()) {
                buildSession.add(file);
              } else if (stat.isDirectory()) {
                scanCompletePromise.when(scanDir(file));
              }
            }
            return scanCompletePromise.then(function() {
              return sessionCompletePromise.when(buildSession.complete());
            });
          }).then(function() {
            return _this._emitCompletePromise.resolve();
          });
        });
        return _this._previousSessionPromise = currentSessionPromise;
      };
    })(this));
  };

  ProjectBuilder.prototype.watchDir = function(dir) {
    if (this.params.watch) {
      return this.watcher.addDir(dir);
    }
  };

  ProjectBuilder.prototype.buildIndex = function() {

    /*
    Builds only `index.html` file for phonegap application.
    This task is need to be run after cordjs optimizer with --remove-sources option
     to avoid rebuilding project due to removed js sources.
    Project need to be completely build before this command can be run.
     */
    var start;
    if (this.params.indexPageWidget) {
      start = process.hrtime();
      return requirejsConfig(this.params.targetDir).then((function(_this) {
        return function() {
          var info;
          info = {
            isIndexPage: true,
            configName: _this.params.config
          };
          return buildManager.createTask(_this.params.indexPageWidget, _this.params.baseDir, _this.params.targetDir, info);
        };
      })(this)).then(function() {
        return 'completed';
      })["catch"](function(err) {
        console.error("Build error", err, err.stack);
        return 'failed';
      }).then((function(_this) {
        return function(verb) {
          var diff;
          diff = process.hrtime(start);
          console.log("Build " + verb + " in " + (parseFloat((diff[0] * 1e9 + diff[1]) / 1e9).toFixed(3)) + " s");
          if (verb === 'completed') {
            buildManager.stop();
            return _this.emit('complete');
          }
        };
      })(this)).failAloud('ProjectBuilder::buildIndex');
    } else {
      return console.error("--index (-I) param is required for the 'buildIndex' command!");
    }
  };

  return ProjectBuilder;

})(EventEmitter);

sourceModified = function(file, srcStat, targetDir, info) {

  /*
  Asynchronously returns true if destination built file modification time is earlier than the source
   (file need to be recompiled)
  @param String file relative file name
  @param StatInfo srcStat result of stat-call for the source file
  @param String targetDir base directory for destination file
  @param Object info framework-related information about the file
  @return Future[Boolean]
   */
  var dstPath;
  dstPath = path.join(targetDir, fileInfo.getBuildDestinationFile(file, info));
  return Future.call(fs.stat, dstPath).then(function(dstStat) {
    return srcStat.mtime.getTime() > dstStat.mtime.getTime();
  })["catch"](function() {
    return true;
  });
};

module.exports = ProjectBuilder;
