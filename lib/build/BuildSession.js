// Generated by CoffeeScript 1.8.0
var BuildSession, Future, buildManager, fileInfo, fs, path, requirejs;

fs = require('fs');

path = require('path');

requirejs = require(process.cwd() + '/node_modules/requirejs');

Future = require('../utils/Future');

buildManager = require('./BuildManager');

fileInfo = require('./FileInfo');

BuildSession = (function() {

  /*
  Organizes build of the applied files in the right order sequence in terms of cordjs framework.
   */
  BuildSession.APP_CONF_FILE = 'public/app/application';

  BuildSession.prototype._completePromise = null;

  BuildSession.prototype._corePromise = null;

  BuildSession.prototype._widgetClassesPromise = null;

  BuildSession.prototype._appConfPromise = null;

  BuildSession.prototype._pathUtilsPromise = null;

  BuildSession.prototype._relativePos = 0;

  function BuildSession(params) {
    this.params = params;
    this._relativePos = this.params.baseDir.length + 1;
    this._completePromise = new Future(1);
    this._corePromise = new Future(1);
    this._widgetClassesPromise = new Future(1);
    this._appConfPromise = new Future(1);
    this._pathUtilsPromise = new Future(1);
    this._completePromise.when(this._appConfPromise, this._pathUtilsPromise);
  }

  BuildSession.prototype.add = function(file) {

    /*
    Adds file to the build session
    @param String file absolute file path
    @return Future
     */
    file = file.substr(this._relativePos);
    if (file === BuildSession.APP_CONF_FILE + '.coffee') {
      this._appConfPromise.fork();
      return this._handleFile(file).done((function(_this) {
        return function() {
          requirejs.config({
            baseUrl: _this.params.targetDir
          });
          return requirejs([BuildSession.APP_CONF_FILE], function(bundles) {
            _this._handleBundlesChange(bundles);
            return _this._appConfPromise.resolve();
          });
        };
      })(this));
    } else if (file === BuildSession.PATH_UTILS_FILE) {
      return this._handleFile(file, 'cord/core').link(this._pathUtilsPromise);
    } else {
      return this._appConfPromise.andThen((function(_this) {
        return function() {
          return _this._handleFile(file, fileInfo.detectBundle(file)).mapFail(function() {
            console.error("Build task failed for\n" + file);
            return null;
          }).link(_this._completePromise);
        };
      })(this)).link(this._completePromise);
    }
  };

  BuildSession.prototype.complete = function() {

    /*
    Indicates that all files are added for this session.
    @return Future completes when the build session is completed
     */
    this._appConfPromise.resolve();
    this._pathUtilsPromise.resolve();
    this._corePromise.resolve();
    this._widgetClassesPromise.resolve();
    this._completePromise.resolve();
    return this._completePromise;
  };

  BuildSession.prototype._handleBundlesChange = function(bundles) {

    /*
    Calculates bundles diff, removes old bundles from build, adds new bundles files to build
     */
  };

  BuildSession.prototype._handleFile = function(file, bundle) {
    var info;
    info = fileInfo.getFileInfo(file, bundle);
    if (info.isStylus) {
      return this._pathUtilsPromise.flatMap((function(_this) {
        return function() {
          return _this._createTask(file, info);
        };
      })(this));
    } else if (info.inWidgets) {
      if (info.isWidget) {
        return this._corePromise.flatMap((function(_this) {
          return function() {
            return _this._createTask(file, info);
          };
        })(this)).link(this._widgetClassesPromise);
      } else if (info.isWidgetTemplate) {
        return this._widgetClassesPromise.flatMap((function(_this) {
          return function() {
            return _this._createTask(file, info);
          };
        })(this));
      } else {
        return this._createTask(file, info);
      }
    } else if (bundle === 'cord/core') {
      return this._createTask(file, info).link(this._corePromise);
    } else {
      return this._createTask(file, info);
    }
  };

  BuildSession.prototype._createTask = function(file, info) {
    return this._sourceModified(file, info).flatMap((function(_this) {
      return function(modified) {
        if (modified) {
          return buildManager.createTask(file, _this.params.baseDir, _this.params.targetDir, info);
        } else {
          return Future.resolved();
        }
      };
    })(this));
  };

  BuildSession.prototype._sourceModified = function(file, info) {

    /*
    Asynchronously returns true if destination built file modification time is earlier than the source
     (file need to be recompiled)
    @param String file relative file name
    @param Object info framework-related information about the file
    @return Future[Boolean]
     */
    var dstPath, srcPath;
    srcPath = path.join(this.params.baseDir, file);
    dstPath = path.join(this.params.targetDir, fileInfo.getBuildDestinationFile(file, info));
    return Future.call(fs.stat, srcPath).zip(Future.call(fs.stat, dstPath)).map(function(srcStat, dstStat) {
      return srcStat.mtime.getTime() > dstStat.mtime.getTime();
    }).mapFail(function() {
      return true;
    });
  };

  return BuildSession;

})();

module.exports = BuildSession;
