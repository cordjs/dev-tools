// Generated by CoffeeScript 1.9.1
var BuildTask, CompileTemplateToVdom, Future, _, astToHyperscript, compilePropValue, compileWidget, dustVdom, fs, mergeTextChunks, mkdirp, path, propsToHyperscript,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

fs = require('fs');

path = require('path');

mkdirp = require('mkdirp');

_ = require('underscore');

Future = require('../../utils/Future');

BuildTask = require('./BuildTask');

dustVdom = require('./dust-vdom');

CompileTemplateToVdom = (function(superClass) {
  extend(CompileTemplateToVdom, superClass);

  function CompileTemplateToVdom() {
    return CompileTemplateToVdom.__super__.constructor.apply(this, arguments);
  }

  CompileTemplateToVdom.prototype.run = function() {
    var basename, compilePromise, dirname, dst, src;
    dirname = path.dirname(this.params.file);
    basename = path.basename(this.params.file, '.html');
    src = this.params.baseDir + "/" + this.params.file;
    dst = this.params.targetDir + "/" + dirname + "/" + basename + ".js";
    compilePromise = Future.call(fs.readFile, src, 'utf8').then((function(_this) {
      return function(dustString) {
        var ast, hyperscript;
        ast = dustVdom.parse(dustString);
        console.log("----------------VDOM-------------------------");
        console.log(JSON.stringify(ast, null, 2));
        console.log("---------------------------------------------");
        if (ast.length > 1) {
          console.warn("Only single root node is allowed for the widget! Using only first of " + ast.length + "! [" + src + "]");
          ast = [ast[0]];
        }
        hyperscript = astToHyperscript(ast, 1);
        console.log(hyperscript);
        console.log("---------------------------------------------");
        return "define(['cord!vdom/vhyperscript/h'],function(h){\n  var w = h.w;\n  return function(props, state, calc){ return " + hyperscript + "; };\n});";
      };
    })(this));
    return Future.all([compilePromise, Future.call(mkdirp, path.dirname(dst))]).spread((function(_this) {
      return function(vdomJs) {
        return Future.call(fs.writeFile, dst, vdomJs);
      };
    })(this)).link(this.readyPromise).failAloud('CompileTemplateToVdom::run');
  };

  return CompileTemplateToVdom;

})(BuildTask);

astToHyperscript = function(ast, indent) {
  var childIndent, chunks, contentsStr, idStr, indentPrefix, node, prevIndentPrefix, propsStr;
  if (indent == null) {
    indent = 0;
  }
  indentPrefix = (new Array(indent * 2 + 1)).join(' ');
  prevIndentPrefix = indent > 0 ? (new Array((indent - 1) * 2 + 1)).join(' ') : '';
  childIndent = ast.length > 1 ? "\n" + indentPrefix : '';
  chunks = (function() {
    var j, len, results;
    results = [];
    for (j = 0, len = ast.length; j < len; j++) {
      node = ast[j];
      switch (node.type) {
        case 'html_tag':
          if (node.name === 'widget') {
            results.push(compileWidget(node, indent));
          } else {
            contentsStr = '';
            if (node.contents) {
              contentsStr = astToHyperscript(node.contents, indent + 1);
            }
            if (contentsStr) {
              contentsStr = ', ' + contentsStr;
            }
            propsStr = propsToHyperscript(node.props, indent);
            idStr = indent === 0 ? "+'#'+props.id" : '';
            results.push("h('" + node.name + "'" + idStr + propsStr + contentsStr + ")");
          }
          break;
        case 'text':
          results.push("'" + node.text + "'");
          break;
        case 'expr':
          results.push("String(" + node.code + ")");
          break;
        default:
          results.push(void 0);
      }
    }
    return results;
  })();
  chunks = mergeTextChunks(chunks, ast);
  if (chunks.length > 1) {
    return "[" + childIndent + (chunks.join(',' + childIndent)) + "\n" + prevIndentPrefix + "]";
  } else if (chunks.length === 1) {
    return chunks[0];
  } else {
    return '';
  }
};

compileWidget = function(node, indent) {
  var contentsStr, i, j, len, prop, propsStr, ref, type;
  if (indent == null) {
    indent = 0;
  }
  contentsStr = '';
  if (node.contents) {
    contentsStr = astToHyperscript(node.contents, indent + 1);
  }
  if (contentsStr) {
    contentsStr = ', ' + contentsStr;
  }
  ref = node.props;
  for (i = j = 0, len = ref.length; j < len; i = ++j) {
    prop = ref[i];
    if (prop.name === 'type') {
      type = compilePropValue(prop.value);
      node.props.splice(i, 1);
      break;
    }
  }
  propsStr = propsToHyperscript(node.props, indent);
  return "w(" + type + propsStr + contentsStr + ")";
};

compilePropValue = function(propValue) {
  if (_.isString(propValue)) {
    return "'" + propValue + "'";
  } else if (_.isObject(propValue)) {
    switch (propValue.type) {
      case 'expr':
        return propValue.code;
      default:
        throw new Error("Invalid prop value type '" + propValue.type + "'!");
    }
  } else {
    throw new Error("Invalid prop value type parsed: " + propValue + "!");
  }
};

mergeTextChunks = function(chunks, ast) {
  var curVtext, i, j, len, node, prevVtext, ref, result;
  result = [];
  prevVtext = false;
  for (i = j = 0, len = ast.length; j < len; i = ++j) {
    node = ast[i];
    curVtext = (ref = node.type) === 'text' || ref === 'expr';
    if (curVtext && prevVtext) {
      result[result.length - 1] += ' + ' + chunks[i];
    } else {
      result.push(chunks[i]);
    }
    prevVtext = curVtext;
  }
  return result;
};

propsToHyperscript = function(props, indent) {
  var chunks, indentStr, pairs, prevIndentPrefix, propInfo, value;
  if (indent == null) {
    indent = 0;
  }
  if (!props || props.length === 0) {
    return '';
  }
  chunks = (function() {
    var j, len, results;
    results = [];
    for (j = 0, len = props.length; j < len; j++) {
      propInfo = props[j];
      value = compilePropValue(propInfo.value);
      results.push(propInfo.name + ": " + value);
    }
    return results;
  })();
  pairs = chunks.length > 1 ? (indentStr = "\n" + (new Array((indent + 1) * 2 + 1)).join(' '), prevIndentPrefix = (new Array(indent * 2 + 1)).join(' '), "" + indentStr + (chunks.join(',' + indentStr)) + "\n" + prevIndentPrefix) : " " + chunks[0] + " ";
  return ", {" + pairs + "}";
};

module.exports = CompileTemplateToVdom;
