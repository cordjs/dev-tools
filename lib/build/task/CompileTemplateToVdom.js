// Generated by CoffeeScript 1.8.0
var BuildTask, CompileTemplateToVdom, Future, astToHyperscript, dustVdom, fs, mergeTextChunks, mkdirp, path,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

fs = require('fs');

path = require('path');

mkdirp = require('mkdirp');

Future = require('../../utils/Future');

BuildTask = require('./BuildTask');

dustVdom = require('./dust-vdom');

CompileTemplateToVdom = (function(_super) {
  __extends(CompileTemplateToVdom, _super);

  function CompileTemplateToVdom() {
    return CompileTemplateToVdom.__super__.constructor.apply(this, arguments);
  }

  CompileTemplateToVdom.prototype.run = function() {
    var basename, dirname, dst, src;
    dirname = path.dirname(this.params.file);
    basename = path.basename(this.params.file, '.html');
    src = "" + this.params.baseDir + "/" + this.params.file;
    dst = "" + this.params.targetDir + "/" + dirname + "/" + basename + ".js";
    return Future.call(fs.readFile, src, 'utf8').then((function(_this) {
      return function(dustString) {
        var ast, hyperscript;
        ast = dustVdom.parse(dustString);
        console.log("----------------VDOM-------------------------");
        console.log(JSON.stringify(ast, null, 2));
        console.log("---------------------------------------------");
        if (ast.length > 1) {
          console.warn("Only single root node is allowed for the widget! Using only first of " + ast.length + "! [" + src + "]");
          ast = [ast[0]];
        }
        hyperscript = astToHyperscript(ast);
        console.log(hyperscript);
        console.log("---------------------------------------------");
        return "define(['cord!vdom/vhyperscript/h'],function(h){ return function(props, state, calc){ return " + hyperscript + ";};});";
      };
    })(this)).zip(Future.call(mkdirp, path.dirname(dst))).then((function(_this) {
      return function(vdomJs) {
        return Future.call(fs.writeFile, dst, vdomJs);
      };
    })(this)).link(this.readyPromise).failAloud();
  };

  return CompileTemplateToVdom;

})(BuildTask);

astToHyperscript = function(ast, indent) {
  var childIndent, chunks, contentsStr, idStr, indentPrefix, node, prevIndentPrefix;
  if (indent == null) {
    indent = 0;
  }
  indentPrefix = (new Array(indent * 2 + 1)).join(' ');
  prevIndentPrefix = indent > 0 ? (new Array((indent - 1) * 2 + 1)).join(' ') : '';
  childIndent = ast.length > 1 ? "\n" + indentPrefix : '';
  chunks = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = ast.length; _i < _len; _i++) {
      node = ast[_i];
      switch (node.type) {
        case 'html_tag':
          contentsStr = '';
          if (node.contents) {
            contentsStr = astToHyperscript(node.contents, indent + 1);
          }
          if (contentsStr) {
            contentsStr = ', ' + contentsStr;
          }
          idStr = indent === 0 ? "+'#'+props.id" : '';
          _results.push("h('" + node.name + "'" + idStr + contentsStr + ")");
          break;
        case 'text':
          _results.push("'" + node.text + "'");
          break;
        case 'expr':
          _results.push("String(" + node.code + ")");
          break;
        default:
          _results.push(void 0);
      }
    }
    return _results;
  })();
  chunks = mergeTextChunks(chunks, ast);
  if (chunks.length > 1) {
    return "[" + childIndent + (chunks.join(',' + childIndent)) + "\n" + prevIndentPrefix + "]";
  } else if (chunks.length === 1) {
    return chunks[0];
  } else {
    return '';
  }
};

mergeTextChunks = function(chunks, ast) {
  var curVtext, i, node, prevVtext, result, _i, _len, _ref;
  result = [];
  prevVtext = false;
  for (i = _i = 0, _len = ast.length; _i < _len; i = ++_i) {
    node = ast[i];
    curVtext = (_ref = node.type) === 'text' || _ref === 'expr';
    if (curVtext && prevVtext) {
      result[result.length - 1] += ' + ' + chunks[i];
    } else {
      result.push(chunks[i]);
    }
    prevVtext = curVtext;
  }
  return result;
};

module.exports = CompileTemplateToVdom;
