// Generated by CoffeeScript 1.9.1
var BuildTask, CompileTemplateToVdom, Future, _, astToHyperscript, blockFnNameCounter, compilePropValue, compileWidget, createBlockFn, detectUsedContext, dustVdom, formatBlockFnCall, fs, mergeTextChunks, mkdirp, path, possibleContextNames, propsToHyperscript,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

fs = require('fs');

path = require('path');

mkdirp = require('mkdirp');

_ = require('underscore');

Future = require('../../utils/Future');

BuildTask = require('./BuildTask');

dustVdom = require('./dust-vdom');

blockFnNameCounter = 0;

CompileTemplateToVdom = (function(superClass) {
  extend(CompileTemplateToVdom, superClass);

  function CompileTemplateToVdom() {
    return CompileTemplateToVdom.__super__.constructor.apply(this, arguments);
  }

  CompileTemplateToVdom.prototype.run = function() {
    var basename, compilePromise, dirname, dst, src;
    dirname = path.dirname(this.params.file);
    basename = path.basename(this.params.file, '.html');
    src = this.params.baseDir + "/" + this.params.file;
    dst = this.params.targetDir + "/" + dirname + "/" + basename + ".js";
    compilePromise = Future.call(fs.readFile, src, 'utf8').then((function(_this) {
      return function(dustString) {
        var ast, info;
        ast = dustVdom.parse(dustString);
        console.log("---------------------------------------------");
        if (ast.length > 1) {
          console.warn("Only single root node is allowed for the widget! Using only first of " + ast.length + "! [" + src + "]");
          ast = [ast[0]];
        }
        blockFnNameCounter = 0;
        info = astToHyperscript(ast, 1);
        console.log(info.hyperscript);
        console.log("---------------------------------------------");
        return "define(['cord!vdom/vhyperscript/h'],function(h){\n  var w = h.w;\n  " + (info.blockFns.join("\n  ")) + "\n  return function(props, state, calc){ return " + info.hyperscript + "; };\n});";
      };
    })(this));
    return Future.all([compilePromise, Future.call(mkdirp, path.dirname(dst))]).spread((function(_this) {
      return function(vdomJs) {
        return Future.call(fs.writeFile, dst, vdomJs);
      };
    })(this)).link(this.readyPromise).failAloud('CompileTemplateToVdom::run');
  };

  return CompileTemplateToVdom;

})(BuildTask);

astToHyperscript = function(ast, indent) {
  var childIndent, chunks, contentsInfo, contentsStr, fnName, indentPrefix, localUsedContext, node, prevIndentPrefix, propsInfo, resultInfo;
  if (indent == null) {
    indent = 0;
  }

  /*
  Recursively converts AST subtree to the hyperscript code fragment
  @param {Array.<Object>} ast - list of entries generated by pegjs parser
  @param {number=} indent - integer indentation level (to generate properly formatted code)
  @return {Object} structure with three fields:
                   * usedContext {Array.<string>} - list of vars used in this section of ast and need to be passed down
                   * blockFns {Array.<string>} - list of compiled block functions that need to be included as a private
                                                 functions to the script
                   * hyperscript {string} - JS-code, hyperscript section of the given AST including children sections,
                                            refers to the functions declared in blockFns
   */
  indentPrefix = (new Array(indent * 2 + 1)).join(' ');
  prevIndentPrefix = indent > 0 ? (new Array((indent - 1) * 2 + 1)).join(' ') : '';
  childIndent = ast.length > 1 ? "\n" + indentPrefix : '';
  resultInfo = {
    usedContext: [],
    blockFns: []
  };
  chunks = (function() {
    var j, len, results;
    results = [];
    for (j = 0, len = ast.length; j < len; j++) {
      node = ast[j];
      switch (node.type) {
        case 'html_tag':
          if (node.name === 'widget') {
            results.push(compileWidget(node, indent));
          } else {
            contentsStr = '';
            if (node.contents) {
              contentsInfo = astToHyperscript(node.contents, indent + 1);
              if (contentsInfo.hyperscript) {
                contentsStr = ', ' + contentsInfo.hyperscript;
              }
              resultInfo.usedContext = _.union(resultInfo.usedContext, contentsInfo.usedContext);
              resultInfo.blockFns = contentsInfo.blockFns.concat(resultInfo.blockFns);
            }
            propsInfo = propsToHyperscript(node.props, indent);
            console.log("props", node.name, node.props);
            results.push("h('" + node.name + propsInfo.idStr + "'" + propsInfo.propsStr + contentsStr + ")");
          }
          break;
        case 'section':
          if (node.modifier === '?') {
            if (node.contents) {
              contentsInfo = astToHyperscript(node.contents, indent + 1);
              resultInfo.blockFns = contentsInfo.blockFns.concat(resultInfo.blockFns);
              localUsedContext = _.union(contentsInfo.usedContext, detectUsedContext(node.name));
              resultInfo.usedContext = _.union(resultInfo.usedContext, localUsedContext);
              fnName = createBlockFn(resultInfo.blockFns, localUsedContext, "if (" + node.name + ") { return " + contentsInfo.hyperscript + "; }");
              results.push(formatBlockFnCall(fnName, localUsedContext));
            } else {
              results.push(void 0);
            }
          } else {
            throw new Error("Modifier '" + node.modifier + "' for section " + node.name + " is not supported yet!");
          }
          break;
        case 'text':
          results.push("'" + node.text + "'");
          break;
        case 'expr':
          resultInfo.usedContext = _.union(resultInfo.usedContext, detectUsedContext(node.code));
          results.push("String(" + node.code + ")");
          break;
        default:
          results.push(void 0);
      }
    }
    return results;
  })();
  chunks = mergeTextChunks(chunks, ast);
  resultInfo.hyperscript = chunks.length > 1 ? "[" + childIndent + (chunks.join(',' + childIndent)) + "\n" + prevIndentPrefix + "]" : chunks.length === 1 ? chunks[0] : '';
  return resultInfo;
};

compileWidget = function(node, indent) {
  var contentsStr, i, j, len, prop, propsInfo, ref, type;
  if (indent == null) {
    indent = 0;
  }
  contentsStr = '';
  if (node.contents) {
    contentsStr = astToHyperscript(node.contents, indent + 1);
  }
  if (contentsStr) {
    contentsStr = ', ' + contentsStr;
  }
  ref = node.props;
  for (i = j = 0, len = ref.length; j < len; i = ++j) {
    prop = ref[i];
    if (prop.name === 'type') {
      type = compilePropValue(prop.value);
      node.props.splice(i, 1);
      break;
    }
  }
  propsInfo = propsToHyperscript(node.props, indent);
  return "w(" + type + propsInfo.propsStr + contentsStr + ")";
};

compilePropValue = function(propValue) {
  if (_.isString(propValue)) {
    return "'" + propValue + "'";
  } else if (_.isObject(propValue)) {
    switch (propValue.type) {
      case 'expr':
        return propValue.code;
      default:
        throw new Error("Invalid prop value type '" + propValue.type + "'!");
    }
  } else {
    throw new Error("Invalid prop value type parsed: " + propValue + "!");
  }
};

mergeTextChunks = function(chunks, ast) {
  var curVtext, i, j, len, node, prevVtext, ref, result;
  result = [];
  prevVtext = false;
  for (i = j = 0, len = ast.length; j < len; i = ++j) {
    node = ast[i];
    if (chunks[i] != null) {
      curVtext = (ref = node.type) === 'text' || ref === 'expr';
      if (curVtext && prevVtext) {
        result[result.length - 1] += ' + ' + chunks[i];
      } else {
        result.push(chunks[i]);
      }
      prevVtext = curVtext;
    }
  }
  return result;
};

propsToHyperscript = function(props, indent) {
  var chunks, indentStr, j, len, pairs, prevIndentPrefix, propInfo, result, value;
  if (indent == null) {
    indent = 0;
  }

  /*
  Converts props came from AST to the JSON to be added to the hyperscript code
  `id` property is treated separately
  @param {Array.<Object>} props
  @param {number} indent
  @return {Object} structure with two fields:
                   * idStr {string} - hyperscript shortcut for id property if applicable (like a#my-id)
                   * propsStr {string} - formatted props JSON object to be added to hyperscript
   */
  result = {
    idStr: '',
    propsStr: ''
  };
  if (!props) {
    return result;
  }
  chunks = [];
  for (j = 0, len = props.length; j < len; j++) {
    propInfo = props[j];
    if (propInfo.name !== 'id' || !_.isString(propInfo.value)) {
      value = compilePropValue(propInfo.value);
      chunks.push(propInfo.name + ": " + value);
    } else {
      result.idStr = '#' + propInfo.value;
    }
  }
  if (chunks.length === 0) {
    return result;
  }
  pairs = chunks.length > 1 ? (indentStr = "\n" + (new Array((indent + 1) * 2 + 1)).join(' '), prevIndentPrefix = (new Array(indent * 2 + 1)).join(' '), "" + indentStr + (chunks.join(',' + indentStr)) + "\n" + prevIndentPrefix) : " " + chunks[0] + " ";
  result.propsStr = ", {" + pairs + "}";
  return result;
};

createBlockFn = function(fns, argNames, body) {

  /*
  Generates a new block function and adds it to the given block functions container
  @param {Array.<string>} fns - container of the block function to which the generated function is added
  @param {Array.<string>} argNames - list of argument names of the declared function
  @param {string} body - JS-code of the given function (without braces)
  @return {string} name of the created function
   */
  var fnName;
  fnName = 'b' + (blockFnNameCounter++);
  fns.push("function " + fnName + "(" + (argNames.join(', ')) + ") { " + body + " }");
  return fnName;
};

formatBlockFnCall = function(fnName, argNames) {

  /*
  Returns JS function-call code by the function name and list of arguments
  @param {string} fnName
  @param {Array.<string>} argNames
  @return {string}
   */
  return fnName + "(" + (argNames.join(', ')) + ")";
};

possibleContextNames = ['props', 'state', 'calc'];

detectUsedContext = function(code) {

  /*
  Finds used context roots in the given JS-code using dumb substring matching
  @param {string} code
  @return {Array.<string>}
   */
  return possibleContextNames.filter(function(x) {
    return code.indexOf(x) > -1;
  });
};

module.exports = CompileTemplateToVdom;
