// Generated by CoffeeScript 1.9.1
var BuildWorkerManager, Future, MAX_WORKERS, _, findBestWorker, joinTheQueue, os, processWorkerQueue, queueActivated, self, taskIdCounter, workerQueue, workers;

_ = require('underscore');

os = require('os');

Future = require('../utils/Future');

BuildWorkerManager = require('./BuildWorkerManager');

MAX_WORKERS = Math.max(os.cpus().length, 2);

workers = [];

taskIdCounter = 0;

workerQueue = [];

queueActivated = false;

joinTheQueue = function() {

  /*
  Creates a new promise, puts it to the queue and returns it.
  It'll be completed with the free build worker when the promise is first in the queue.
  @return {Future<BuildWorkerManager>}
   */
  var resultPromise;
  resultPromise = Future.single();
  workerQueue.push(resultPromise);
  if (!queueActivated) {
    processWorkerQueue();
  }
  return resultPromise;
};

processWorkerQueue = function() {

  /*
  Fulfills waiting promises from the queue with the free workers as they are getting free.
  Works until the queue is empty.
   */
  queueActivated = true;
  Future.any(workers.map(function(w) {
    return w.acceptReady();
  })).then(function(worker) {
    if (worker.canAcceptTask()) {
      workerQueue.shift().resolve(worker);
    }
    if (workerQueue.length) {
      processWorkerQueue();
    } else {
      queueActivated = false;
    }
  }).failAloud('processWorkerQueue');
};

findBestWorker = function() {

  /*
  Chooses best worker process (less loaded) for the next file.
  @return {Future<BuildWorkerManager>}
   */
  var emptyWorker, freeWorkers, newWorker, sorted;
  emptyWorker = _.find(workers, function(w) {
    return w.getWorkload() === 0;
  });
  if (emptyWorker) {
    return Future.resolved(emptyWorker);
  } else {
    if (workers.length < MAX_WORKERS) {
      newWorker = new BuildWorkerManager(self);
      workers.push(newWorker);
      return Future.resolved(newWorker);
    } else {
      freeWorkers = workers.filter(function(w) {
        return w.canAcceptTask();
      });
      if (freeWorkers.length) {
        sorted = _.sortBy(freeWorkers, function(w) {
          return w.getWorkload();
        });
        return Future.resolved(sorted[0]);
      } else {
        return joinTheQueue();
      }
    }
  }
};

module.exports = self = {

  /*
  Build worker process manager and load balancer for the build tasks
  @static
   */
  generateSourceMap: false,
  createTask: function(relativeFilePath, baseDir, targetDir, fileInfo) {

    /*
    Assigns a new task based on the given params to the free build worker
    @param {String} relativeFlePath - file to be built
    @param {String} baseDir - base dir of the building project
    @param {String} targetDir
    @param {Object} fileInfo - special precomputed file properties used by the build task
    @return {Future<undefined>} promise is complete when the build task is complete
     */
    return findBestWorker().then((function(_this) {
      return function(worker) {
        return worker.addTask({
          id: ++taskIdCounter,
          file: relativeFilePath,
          baseDir: baseDir,
          targetDir: targetDir,
          info: fileInfo,
          generateSourceMap: _this.generateSourceMap
        });
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        if (err.overwhelmed) {
          return _this.createTask(relativeFilePath, baseDir, targetDir, fileInfo);
        } else {
          throw err;
        }
      };
    })(this));
  },
  stop: function() {

    /*
    Immediately stops all build workers
     */
    while (workers.length) {
      workers[0].stop();
    }
  },
  stopWorker: function(worker) {

    /*
    Removes the given worker from the workers array.
    Called from the build worker to consistently complete its stopping.
    @internal
    @param {BuildWorkerManager} worker
     */
    workers = _.without(workers, worker);
    if (false) {
      console.log("Worker " + worker.id + " stopped. Total tasks count: " + worker.totalTasksCount);
    }
  }
};
