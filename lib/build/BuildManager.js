// Generated by CoffeeScript 1.7.1
var BuildManager, BuildWorkerManager, Future, os, _;

_ = require('underscore');

os = require('os');

Future = require('../utils/Future');

BuildWorkerManager = require('./BuildWorkerManager');

BuildManager = (function() {
  function BuildManager() {}


  /*
  Build worker process manager and load balancer for the build tasks
  @static
   */

  BuildManager.workers = [];

  BuildManager.MAX_WORKERS = Math.max(os.cpus().length, 2);

  BuildManager._taskIdCounter = 0;

  BuildManager.generateSourceMap = false;

  BuildManager.createTask = function(relativeFilePath, baseDir, targetDir, fileInfo) {
    return this.findBestWorker().flatMap((function(_this) {
      return function(worker) {
        return worker.addTask({
          id: ++_this._taskIdCounter,
          file: relativeFilePath,
          baseDir: baseDir,
          targetDir: targetDir,
          info: fileInfo,
          generateSourceMap: _this.generateSourceMap
        });
      };
    })(this));
  };

  BuildManager.findBestWorker = function() {

    /*
    Chooses best worker process (less loaded) for the next file.
    @return Future[Worker]
     */
    var emptyWorker, freeWorkers, newWorker, recursiveWait, result, sorted;
    result = Future.single();
    emptyWorker = _.find(this.workers, function(w) {
      return w.getWorkload() === 0;
    });
    if (emptyWorker) {
      result.resolve(emptyWorker);
    } else {
      if (this.workers.length < this.MAX_WORKERS) {
        newWorker = new BuildWorkerManager(this);
        this.workers.push(newWorker);
        result.resolve(newWorker);
      } else {
        freeWorkers = _.filter(this.workers, function(w) {
          return w.canAcceptTask();
        });
        if (freeWorkers.length) {
          sorted = _.sortBy(freeWorkers, function(w) {
            return w.getWorkload();
          });
          result.resolve(sorted[0]);
        } else {
          recursiveWait = (function(_this) {
            return function() {
              return Future.select(_.map(_this.workers, function(w) {
                return w.acceptReady();
              })).done(function(worker) {
                if (worker.canAcceptTask()) {
                  return result.resolve(worker);
                } else {
                  return recursiveWait();
                }
              });
            };
          })(this);
          recursiveWait();
        }
      }
    }
    return result;
  };

  BuildManager.stop = function() {
    var w, _i, _len, _ref, _results;
    _ref = this.workers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      w = _ref[_i];
      _results.push(w.stop());
    }
    return _results;
  };

  BuildManager.stopWorker = function(worker) {
    this.workers = _.without(this.workers, worker);
    if (false) {
      return console.log("Worker " + worker.id + " stopped. Total tasks count: " + worker.totalTasksCount);
    }
  };

  return BuildManager;

})();

module.exports = BuildManager;
