// Generated by CoffeeScript 1.9.1
var EventEmitter, Future, ProjectWatcher, _, fs, path,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

fs = require('fs');

path = require('path');

_ = require('underscore');

Future = require('../utils/Future');

ProjectWatcher = (function(superClass) {
  extend(ProjectWatcher, superClass);


  /*
  Directory tree watcher wrapper.
  Emits aggregated 'change' event when some watched files/directories are added/removed/moved
   */

  ProjectWatcher.prototype._watchTree = null;

  ProjectWatcher.prototype._fileByInode = null;

  ProjectWatcher.prototype._inodeByFile = null;

  ProjectWatcher.prototype._analyzeList = null;

  ProjectWatcher.prototype._aggregateTimeout = null;

  ProjectWatcher.prototype._previousAnalyzeAndEmit = null;

  ProjectWatcher.prototype._watcher = null;

  function ProjectWatcher(baseDir) {
    var rootInfo;
    this.baseDir = baseDir;
    rootInfo = {
      dir: this.baseDir,
      watchAll: false,
      children: {},
      contents: null,
      watcher: null
    };
    this._watchTree = rootInfo;
    this._analyzeList = {};
    this._previousAnalyzeAndEmit = Future.resolved();
    this._watcher = (function() {
      try {
        return require('pathwatcher');
      } catch (_error) {
        return fs;
      }
    })();
  }

  ProjectWatcher.prototype.addDir = function(dir) {
    var curParent, err, i, len, part, parts;
    if (dir.indexOf(this.baseDir) === 0) {
      parts = dir.substr(this.baseDir.length).split('/');
      parts = _.compact(parts);
      curParent = this._watchTree;
      try {
        for (i = 0, len = parts.length; i < len; i++) {
          part = parts[i];
          curParent = this._watchDir(curParent, part);
        }
        return curParent.watchAll = true;
      } catch (_error) {
        err = _error;
        return console.error("Watch failed for the directory [" + curParent.dir + "/" + part + "], reason:", err);
      }
    } else {
      throw new Error("Watch directory " + dir + " must be sub-directory of base dir " + this.baseDir + "!");
    }
  };

  ProjectWatcher.prototype._watchDir = function(parentInfo, localName) {
    var dir, watchInfo;
    if (parentInfo.children[localName] != null) {
      return parentInfo.children[localName];
    } else {
      dir = path.join(parentInfo.dir, localName);
      watchInfo = {
        dir: dir,
        watchAll: false,
        children: {},
        contents: this._readdir(dir),
        watcher: this._watcher.watch(dir, (function(_this) {
          return function(event, filename) {
            return _this._handleDir(watchInfo, filename, event);
          };
        })(this))
      };
      parentInfo.children[localName] = watchInfo;
      return watchInfo;
    }
  };

  ProjectWatcher.prototype._readdir = function(dir) {

    /*
    Collects stat-info of all shallow members of the given directory.
    @param String dir absolute directory path
    @return Future[Map[String -> StatInfo]]
     */
    return Future.call(fs.readdir, dir).flatMap(function(dirList) {
      var fList, name;
      fList = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = dirList.length; i < len; i++) {
          name = dirList[i];
          results.push((function(name) {
            return Future.call(fs.lstat, path.join(dir, name)).map(function(stat) {
              stat.name = name;
              return stat;
            });
          })(name));
        }
        return results;
      })();
      return Future.sequence(fList).map(function(statList) {
        var i, len, result, stat;
        result = {};
        for (i = 0, len = statList.length; i < len; i++) {
          stat = statList[i];
          result[stat.name] = stat;
        }
        return result;
      });
    });
  };

  ProjectWatcher.prototype._handleDir = function(watchInfo, filename, event) {
    return this._analyzeDir(watchInfo);
  };

  ProjectWatcher.prototype._analyzeDir = function(watchInfo) {

    /*
    Collects directories to be analyzed together to emit one 'change' event
     */
    this._analyzeList[watchInfo.dir] = watchInfo;
    return this._activateAggregateTimeout();
  };

  ProjectWatcher.prototype._activateAggregateTimeout = function() {
    if (this._aggregateTimeout != null) {
      clearTimeout(this._aggregateTimeout);
    }
    return this._aggregateTimeout = setTimeout((function(_this) {
      return function() {
        var current, previous, tmpList;
        tmpList = _this._analyzeList;
        _this._analyzeList = {};
        _this._aggregateTimeout = null;
        previous = _this._previousAnalyzeAndEmit;
        current = Future.single();
        _this._previousAnalyzeAndEmit = current;
        return previous.done(function() {
          return current.when(_this._analyzeAndEmit(tmpList));
        });
      };
    })(this), 100);
  };

  ProjectWatcher.prototype._analyzeAndEmit = function(dirList) {

    /*
    Analyzes list of directories by diffing their current contents with the saved previous contents and
     emits appropriate 'change' event consumed by project builder
    @param Map[String -> Object]
    @return Future
     */
    var dir, fn, result, summaryChangeMap, summaryRemoveList, watchInfo;
    result = new Future;
    summaryChangeMap = {};
    summaryRemoveList = [];
    fn = (function(_this) {
      return function(dir, watchInfo) {
        var newContents, oldContents;
        result.fork();
        newContents = _this._readdir(dir);
        oldContents = watchInfo.contents;
        watchInfo.contents = newContents;
        return oldContents.zip(newContents).done(function(oldMap, newMap) {
          var addList, changeList, changeMap, i, j, k, len, len1, len2, name, newItems, newStat, oldItems, oldStat, ref, ref1, removeList, removeListFiltered;
          oldItems = Object.keys(oldMap);
          newItems = Object.keys(newMap);
          removeList = _.difference(oldItems, newItems);
          addList = _.difference(newItems, oldItems);
          changeList = [];
          ref = _.intersection(newItems, oldItems);
          for (i = 0, len = ref.length; i < len; i++) {
            name = ref[i];
            newStat = newMap[name];
            oldStat = oldMap[name];
            if (newStat.mtime.getTime() !== oldStat.mtime.getTime()) {
              if ((newStat.isDirectory() && !oldStat.isDirectory()) || (!newStat.isDirectory() && oldStat.isDirectory())) {
                removeList.push(name);
                addList.push(name);
              } else if (!newStat.isDirectory() && !oldStat.isDirectory()) {
                changeList.push(name);
              }
            }
          }
          changeMap = {};
          if (watchInfo.watchAll) {
            ref1 = addList.concat(changeList);
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              name = ref1[j];
              changeMap[path.join(dir, name).replace(/\\/g, '/')] = newMap[name];
            }
          }
          removeListFiltered = [];
          for (k = 0, len2 = removeList.length; k < len2; k++) {
            name = removeList[k];
            if (watchInfo.watchAll || (watchInfo.children[name] != null)) {
              if (watchInfo.children[name] != null) {
                _this._stopWatching(watchInfo.children[name]);
              }
              removeListFiltered.push(path.join(dir, name).replace(/\\/g, '/'));
            }
          }
          _.extend(summaryChangeMap, changeMap);
          summaryRemoveList = summaryRemoveList.concat(removeListFiltered);
          return result.resolve();
        }).fail(function(err) {
          if (err.code === 'ENOENT') {
            _this._stopWatching(watchInfo);
            return result.resolve();
          } else {
            console.error("ERROR: readdir failed", watchInfo, err);
            throw err;
          }
        });
      };
    })(this);
    for (dir in dirList) {
      watchInfo = dirList[dir];
      fn(dir, watchInfo);
    }
    return result.done((function(_this) {
      return function() {
        if (Object.keys(summaryChangeMap).length > 0 || summaryRemoveList.length > 0) {
          return _this.emit('change', {
            removed: summaryRemoveList,
            changed: summaryChangeMap
          });
        }
      };
    })(this));
  };

  ProjectWatcher.prototype._stopWatching = function(watchInfo) {
    var child, name, ref, ref1;
    if ((ref = watchInfo.watcher) != null) {
      ref.close();
    }
    watchInfo.watcher = null;
    ref1 = watchInfo.children;
    for (name in ref1) {
      child = ref1[name];
      this._stopWatching(child);
    }
    return watchInfo.children = {};
  };

  return ProjectWatcher;

})(EventEmitter);

module.exports = ProjectWatcher;
