// Generated by CoffeeScript 1.7.1
var EventEmitter, Future, ProjectWatcher, fs, path, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

fs = require('fs');

path = require('path');

_ = require('underscore');

Future = require('../utils/Future');

ProjectWatcher = (function(_super) {
  __extends(ProjectWatcher, _super);


  /*
  Directory tree watcher wrapper.
  Emits aggregated 'change' event when some watched files/directories are added/removed/moved
   */

  ProjectWatcher.prototype._watchTree = null;

  ProjectWatcher.prototype._fileByInode = null;

  ProjectWatcher.prototype._inodeByFile = null;

  ProjectWatcher.prototype._analyzeList = null;

  ProjectWatcher.prototype._aggregateTimeout = null;

  ProjectWatcher.prototype._previousAnalyzeAndEmit = null;

  ProjectWatcher.prototype._watcher = null;

  function ProjectWatcher(baseDir) {
    var rootInfo;
    this.baseDir = baseDir;
    rootInfo = {
      dir: this.baseDir,
      watchAll: false,
      children: {},
      contents: null,
      watcher: null
    };
    this._watchTree = rootInfo;
    this._analyzeList = {};
    this._previousAnalyzeAndEmit = Future.resolved();
    this._watcher = (function() {
      try {
        return require('pathwatcher');
      } catch (_error) {
        return fs;
      }
    })();
  }

  ProjectWatcher.prototype.addDir = function(dir) {
    var curParent, err, part, parts, _i, _len;
    if (dir.indexOf(this.baseDir) === 0) {
      parts = dir.substr(this.baseDir.length).split('/');
      parts = _.compact(parts);
      curParent = this._watchTree;
      try {
        for (_i = 0, _len = parts.length; _i < _len; _i++) {
          part = parts[_i];
          curParent = this._watchDir(curParent, part);
        }
        return curParent.watchAll = true;
      } catch (_error) {
        err = _error;
        return console.error("Watch failed for the directory [" + curParent.dir + "/" + part + "], reason:", err);
      }
    } else {
      throw new Error("Watch directory " + dir + " must be sub-directory of base dir " + this.baseDir + "!");
    }
  };

  ProjectWatcher.prototype._watchDir = function(parentInfo, localName) {
    var dir, watchInfo;
    if (parentInfo.children[localName] != null) {
      return parentInfo.children[localName];
    } else {
      dir = path.join(parentInfo.dir, localName);
      watchInfo = {
        dir: dir,
        watchAll: false,
        children: {},
        contents: this._readdir(dir),
        watcher: this._watcher.watch(dir, (function(_this) {
          return function(event, filename) {
            return _this._handleDir(watchInfo, filename, event);
          };
        })(this))
      };
      parentInfo.children[localName] = watchInfo;
      return watchInfo;
    }
  };

  ProjectWatcher.prototype._readdir = function(dir) {

    /*
    Collects stat-info of all shallow members of the given directory.
    @param String dir absolute directory path
    @return Future[Map[String -> StatInfo]]
     */
    return Future.call(fs.readdir, dir).flatMap(function(dirList) {
      var fList, name;
      fList = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = dirList.length; _i < _len; _i++) {
          name = dirList[_i];
          _results.push((function(name) {
            return Future.call(fs.lstat, path.join(dir, name)).map(function(stat) {
              stat.name = name;
              return stat;
            });
          })(name));
        }
        return _results;
      })();
      return Future.sequence(fList).map(function(statList) {
        var result, stat, _i, _len;
        result = {};
        for (_i = 0, _len = statList.length; _i < _len; _i++) {
          stat = statList[_i];
          result[stat.name] = stat;
        }
        return result;
      });
    });
  };

  ProjectWatcher.prototype._handleDir = function(watchInfo, filename, event) {
    return this._analyzeDir(watchInfo);
  };

  ProjectWatcher.prototype._analyzeDir = function(watchInfo) {

    /*
    Collects directories to be analyzed together to emit one 'change' event
     */
    this._analyzeList[watchInfo.dir] = watchInfo;
    return this._activateAggregateTimeout();
  };

  ProjectWatcher.prototype._activateAggregateTimeout = function() {
    if (this._aggregateTimeout != null) {
      clearTimeout(this._aggregateTimeout);
    }
    return this._aggregateTimeout = setTimeout((function(_this) {
      return function() {
        var current, previous, tmpList;
        tmpList = _this._analyzeList;
        _this._analyzeList = {};
        _this._aggregateTimeout = null;
        previous = _this._previousAnalyzeAndEmit;
        current = Future.single();
        _this._previousAnalyzeAndEmit = current;
        return previous.done(function() {
          return current.when(_this._analyzeAndEmit(tmpList));
        });
      };
    })(this), 100);
  };

  ProjectWatcher.prototype._analyzeAndEmit = function(dirList) {

    /*
    Analyzes list of directories by diffing their current contents with the saved previous contents and
     emits appropriate 'change' event consumed by project builder
    @param Map[String -> Object]
    @return Future
     */
    var dir, result, summaryChangeMap, summaryRemoveList, watchInfo, _fn;
    result = new Future;
    summaryChangeMap = {};
    summaryRemoveList = [];
    _fn = (function(_this) {
      return function(dir, watchInfo) {
        var newContents, oldContents;
        result.fork();
        newContents = _this._readdir(dir);
        oldContents = watchInfo.contents;
        watchInfo.contents = newContents;
        return oldContents.zip(newContents).done(function(oldMap, newMap) {
          var addList, changeList, changeMap, name, newItems, newStat, oldItems, oldStat, removeList, removeListFiltered, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
          oldItems = Object.keys(oldMap);
          newItems = Object.keys(newMap);
          removeList = _.difference(oldItems, newItems);
          addList = _.difference(newItems, oldItems);
          changeList = [];
          _ref = _.intersection(newItems, oldItems);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            name = _ref[_i];
            newStat = newMap[name];
            oldStat = oldMap[name];
            if (newStat.mtime.getTime() !== oldStat.mtime.getTime()) {
              if ((newStat.isDirectory() && !oldStat.isDirectory()) || (!newStat.isDirectory() && oldStat.isDirectory())) {
                removeList.push(name);
                addList.push(name);
              } else if (!newStat.isDirectory() && !oldStat.isDirectory()) {
                changeList.push(name);
              }
            }
          }
          changeMap = {};
          if (watchInfo.watchAll) {
            _ref1 = addList.concat(changeList);
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              name = _ref1[_j];
              changeMap[path.join(dir, name).replace(/\\/g, '/')] = newMap[name];
            }
          }
          removeListFiltered = [];
          for (_k = 0, _len2 = removeList.length; _k < _len2; _k++) {
            name = removeList[_k];
            if (watchInfo.watchAll || (watchInfo.children[name] != null)) {
              if (watchInfo.children[name] != null) {
                _this._stopWatching(watchInfo.children[name]);
              }
              removeListFiltered.push(path.join(dir, name).replace(/\\/g, '/'));
            }
          }
          _.extend(summaryChangeMap, changeMap);
          summaryRemoveList = summaryRemoveList.concat(removeListFiltered);
          return result.resolve();
        }).fail(function(err) {
          if (err.code === 'ENOENT') {
            _this._stopWatching(watchInfo);
            return result.resolve();
          } else {
            console.error("ERROR: readdir failed", watchInfo, err);
            throw err;
          }
        });
      };
    })(this);
    for (dir in dirList) {
      watchInfo = dirList[dir];
      _fn(dir, watchInfo);
    }
    return result.done((function(_this) {
      return function() {
        if (Object.keys(summaryChangeMap).length > 0 || summaryRemoveList.length > 0) {
          return _this.emit('change', {
            removed: summaryRemoveList,
            changed: summaryChangeMap
          });
        }
      };
    })(this));
  };

  ProjectWatcher.prototype._stopWatching = function(watchInfo) {
    var child, name, _ref, _ref1;
    if ((_ref = watchInfo.watcher) != null) {
      _ref.close();
    }
    watchInfo.watcher = null;
    _ref1 = watchInfo.children;
    for (name in _ref1) {
      child = _ref1[name];
      this._stopWatching(child);
    }
    return watchInfo.children = {};
  };

  return ProjectWatcher;

})(EventEmitter);

module.exports = ProjectWatcher;
